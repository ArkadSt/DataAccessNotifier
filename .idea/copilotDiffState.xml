<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/app/build.gradle.kts">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/build.gradle.kts" />
              <option name="originalContent" value="plugins {&#10;    alias(libs.plugins.android.application)&#10;    alias(libs.plugins.kotlin.android)&#10;    alias(libs.plugins.kotlin.compose)&#10;    alias(libs.plugins.protobuf)&#10;}&#10;&#10;android {&#10;    namespace = &quot;com.arkadst.dataaccessnotifier&quot;&#10;    compileSdk = 36&#10;&#10;    defaultConfig {&#10;        applicationId = &quot;com.arkadst.dataaccessnotifier&quot;&#10;        minSdk = 27&#10;        targetSdk = 36&#10;        versionCode = 1&#10;        versionName = &quot;1.0&quot;&#10;&#10;        testInstrumentationRunner = &quot;androidx.test.runner.AndroidJUnitRunner&quot;&#10;    }&#10;&#10;    buildTypes {&#10;        release {&#10;            isMinifyEnabled = false&#10;            proguardFiles(&#10;                getDefaultProguardFile(&quot;proguard-android-optimize.txt&quot;),&#10;                &quot;proguard-rules.pro&quot;&#10;            )&#10;        }&#10;    }&#10;    compileOptions {&#10;        sourceCompatibility = JavaVersion.VERSION_11&#10;        targetCompatibility = JavaVersion.VERSION_11&#10;    }&#10;    kotlin {&#10;        compilerOptions {&#10;            jvmTarget.set(org.jetbrains.kotlin.gradle.dsl.JvmTarget.JVM_11)&#10;        }&#10;    }&#10;    buildFeatures {&#10;        compose = true&#10;    }&#10;}&#10;&#10;dependencies {&#10;    implementation(libs.protoBuf)&#10;    implementation(libs.proto.datastore)&#10;    implementation(libs.datastore.preferences)&#10;    implementation(libs.kotlinx.serialization.json)&#10;    implementation(libs.kotlinx.coroutines.core)&#10;    implementation(libs.kotlinx.coroutines.android)&#10;    implementation(libs.okhttp)&#10;    implementation(libs.androidx.core.ktx)&#10;    implementation(libs.androidx.lifecycle.runtime.ktx)&#10;    implementation(libs.androidx.activity.compose)&#10;    implementation(platform(libs.androidx.compose.bom))&#10;    implementation(libs.androidx.ui)&#10;    implementation(libs.androidx.ui.graphics)&#10;    implementation(libs.androidx.ui.tooling.preview)&#10;    implementation(libs.androidx.material3)&#10;    testImplementation(libs.junit)&#10;    androidTestImplementation(libs.androidx.junit)&#10;    androidTestImplementation(libs.androidx.espresso.core)&#10;    androidTestImplementation(platform(libs.androidx.compose.bom))&#10;    androidTestImplementation(libs.androidx.ui.test.junit4)&#10;    debugImplementation(libs.androidx.ui.tooling)&#10;    debugImplementation(libs.androidx.ui.test.manifest)&#10;}&#10;&#10;protobuf {&#10;    protoc {&#10;        artifact = &quot;com.google.protobuf:protoc:${libs.versions.protoBuf.get()}&quot;&#10;    }&#10;    generateProtoTasks {&#10;        all().forEach { task -&gt;&#10;            task.builtins {&#10;                create(&quot;java&quot;) {&#10;                    option(&quot;lite&quot;)&#10;                }&#10;            }&#10;        }&#10;    }&#10;}" />
              <option name="updatedContent" value="plugins {&#10;    alias(libs.plugins.android.application)&#10;    alias(libs.plugins.kotlin.android)&#10;    alias(libs.plugins.kotlin.compose)&#10;    alias(libs.plugins.protobuf)&#10;}&#10;&#10;android {&#10;    namespace = &quot;com.arkadst.dataaccessnotifier&quot;&#10;    compileSdk = 36&#10;&#10;    defaultConfig {&#10;        applicationId = &quot;com.arkadst.dataaccessnotifier&quot;&#10;        minSdk = 27&#10;        targetSdk = 36&#10;        versionCode = 1&#10;        versionName = &quot;1.0&quot;&#10;&#10;        testInstrumentationRunner = &quot;androidx.test.runner.AndroidJUnitRunner&quot;&#10;    }&#10;&#10;    buildTypes {&#10;        release {&#10;            isMinifyEnabled = false&#10;            proguardFiles(&#10;                getDefaultProguardFile(&quot;proguard-android-optimize.txt&quot;),&#10;                &quot;proguard-rules.pro&quot;&#10;            )&#10;        }&#10;    }&#10;    compileOptions {&#10;        sourceCompatibility = JavaVersion.VERSION_17&#10;        targetCompatibility = JavaVersion.VERSION_17&#10;    }&#10;    kotlin {&#10;        compilerOptions {&#10;            jvmTarget.set(org.jetbrains.kotlin.gradle.dsl.JvmTarget.JVM_17)&#10;        }&#10;    }&#10;    buildFeatures {&#10;        compose = true&#10;    }&#10;}&#10;&#10;dependencies {&#10;    implementation(libs.protoBuf)&#10;    implementation(libs.proto.datastore)&#10;    implementation(libs.datastore.preferences)&#10;    implementation(libs.kotlinx.serialization.json)&#10;    implementation(libs.kotlinx.coroutines.core)&#10;    implementation(libs.kotlinx.coroutines.android)&#10;    implementation(libs.okhttp)&#10;    implementation(libs.androidx.core.ktx)&#10;    implementation(libs.androidx.lifecycle.runtime.ktx)&#10;    implementation(libs.androidx.activity.compose)&#10;    implementation(platform(libs.androidx.compose.bom))&#10;    implementation(libs.androidx.ui)&#10;    implementation(libs.androidx.ui.graphics)&#10;    implementation(libs.androidx.ui.tooling.preview)&#10;    implementation(libs.androidx.material3)&#10;    testImplementation(libs.junit)&#10;    androidTestImplementation(libs.androidx.junit)&#10;    androidTestImplementation(libs.androidx.espresso.core)&#10;    androidTestImplementation(platform(libs.androidx.compose.bom))&#10;    androidTestImplementation(libs.androidx.ui.test.junit4)&#10;    debugImplementation(libs.androidx.ui.tooling)&#10;    debugImplementation(libs.androidx.ui.test.manifest)&#10;}&#10;&#10;protobuf {&#10;    protoc {&#10;        artifact = &quot;com.google.protobuf:protoc:${libs.versions.protoBuf.get()}&quot;&#10;    }&#10;    generateProtoTasks {&#10;        all().forEach { task -&gt;&#10;            task.builtins {&#10;                create(&quot;java&quot;) {&#10;                    option(&quot;lite&quot;)&#10;                }&#10;            }&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/arkadst/dataaccessnotifier/MainActivity.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/arkadst/dataaccessnotifier/MainActivity.kt" />
              <option name="originalContent" value="package com.arkadst.dataaccessnotifier&#10;&#10;import android.annotation.SuppressLint&#10;import android.content.Context&#10;import android.os.Bundle&#10;import android.util.Log&#10;import android.webkit.CookieManager&#10;import android.webkit.WebView&#10;import android.widget.Toast&#10;import androidx.activity.ComponentActivity&#10;import androidx.activity.compose.setContent&#10;import androidx.activity.enableEdgeToEdge&#10;import androidx.activity.result.ActivityResultLauncher&#10;import androidx.activity.result.contract.ActivityResultContracts&#10;import androidx.compose.foundation.layout.*&#10;import androidx.compose.foundation.lazy.LazyColumn&#10;import androidx.compose.material3.*&#10;import androidx.compose.runtime.*&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.platform.LocalContext&#10;import androidx.compose.ui.unit.dp&#10;import androidx.compose.ui.viewinterop.AndroidView&#10;import com.arkadst.dataaccessnotifier.ui.theme.DataAccessNotifierTheme&#10;import com.arkadst.dataaccessnotifier.Utils.fetchUserInfo&#10;import com.arkadst.dataaccessnotifier.Utils.getURL&#10;import kotlinx.coroutines.launch&#10;import androidx.datastore.preferences.core.edit&#10;import androidx.datastore.preferences.core.stringPreferencesKey&#10;import com.arkadst.dataaccessnotifier.NotificationManager.requestNotificationPermission&#10;import com.arkadst.dataaccessnotifier.Utils.logOut&#10;import com.arkadst.dataaccessnotifier.alarm.AlarmScheduler&#10;import kotlinx.coroutines.flow.map&#10;&#10;const val LOGIN_URL = &quot;https://www.eesti.ee/timur/oauth2/authorization/govsso?callback_url=https://www.eesti.ee/auth/callback&amp;locale=et&quot;&#10;const val SUCCESS_URL = &quot;https://www.eesti.ee/auth/callback&quot;&#10;private const val TAG = &quot;CookieExtraction&quot;&#10;private const val API_TEST_URL = &quot;https://www.eesti.ee/andmejalgija/api/v1/usages?dataSystemCodes=rahvastikuregister&quot;&#10;&#10;class MainActivity : ComponentActivity() {&#10;&#10;    private lateinit var notificationPermissionLauncher: ActivityResultLauncher&lt;String&gt;&#10;    private suspend fun saveCookies(context: Context, cookies: Map&lt;String, String&gt;) {&#10;        context.cookieDataStore.edit { storedCookies -&gt;&#10;            cookies.forEach { (name, value) -&gt;&#10;                storedCookies[stringPreferencesKey(name)] = value&#10;            }&#10;        }&#10;        Log.d(TAG, &quot;Saved ${cookies.size} cookies&quot;)&#10;    }&#10;&#10;&#10;    private fun cookieStringToMap(cookieString: String): Map&lt;String, String&gt;{&#10;        val cookieMap = mutableMapOf&lt;String, String&gt;()&#10;        cookieString.split(&quot;;&quot;).forEach { cookie -&gt;&#10;            val cookiePair = cookie.trim().split(&quot;=&quot;)&#10;            if (cookiePair.size == 2) {&#10;                val cookieName = cookiePair[0].trim()&#10;                cookieMap[cookieName] = cookie&#10;                Log.d(TAG, &quot;Cookie: $cookieName = $cookie&quot;)&#10;            }&#10;        }&#10;        return cookieMap&#10;    }&#10;&#10;&#10;&#10;    override fun onCreate(savedInstanceState: Bundle?) {&#10;        super.onCreate(savedInstanceState)&#10;&#10;        notificationPermissionLauncher = registerForActivityResult(&#10;            ActivityResultContracts.RequestPermission()&#10;        ) { isGranted -&gt;&#10;            if (isGranted) {&#10;                Log.d(TAG, &quot;Notification permission granted&quot;)&#10;                Toast.makeText(this, &quot;Notification permission granted&quot;, Toast.LENGTH_SHORT).show()&#10;            } else {&#10;                Log.d(TAG, &quot;Notification permission denied&quot;)&#10;                Toast.makeText(this, &quot;Notification permission denied. The app won't work without it.&quot;, Toast.LENGTH_SHORT).show()&#10;                this.finishAffinity()&#10;            }&#10;        }&#10;&#10;        LoginStateRepository.init(this)&#10;        WebView.setWebContentsDebuggingEnabled(true)&#10;        enableEdgeToEdge()&#10;        setContent {&#10;            DataAccessNotifierTheme {&#10;                AuthScreen()&#10;            }&#10;        }&#10;    }&#10;&#10;    override fun onResume() {&#10;        super.onResume()&#10;        if (!AlarmScheduler.requestExactAlarmPermissionIfNeeded(this)){&#10;            requestNotificationPermission(this, notificationPermissionLauncher)&#10;        }&#10;    }&#10;&#10;    @Composable&#10;    fun AuthScreen() {&#10;&#10;        val context = LocalContext.current&#10;        val scope = rememberCoroutineScope()&#10;        val isLoggedIn by LoginStateRepository.isLoggedIn.collectAsState()&#10;        var loggingIn by remember { mutableStateOf(false) }&#10;        val authState = when {&#10;            loggingIn -&gt; AuthState.LoggingIn&#10;            isLoggedIn -&gt; AuthState.LoggedIn&#10;            else -&gt; AuthState.LoggedOut&#10;        }&#10;&#10;        Scaffold(modifier = Modifier.fillMaxSize()) { innerPadding -&gt;&#10;            when (authState) {&#10;                AuthState.LoggedOut -&gt; {&#10;                    LoginButton(&#10;                        modifier = Modifier.padding(innerPadding),&#10;                        onLoginClick = {&#10;                            Toast.makeText(context, &quot;Logging in...&quot;, Toast.LENGTH_SHORT).show()&#10;                            loggingIn = true&#10;                        }&#10;                    )&#10;                }&#10;&#10;                AuthState.LoggingIn -&gt; {&#10;&#10;                    AuthWebView(&#10;                        modifier = Modifier.padding(innerPadding),&#10;                        onAuthComplete = { cookies -&gt;&#10;                            scope.launch {&#10;                                //saveCookies(context, cookies)&#10;                                fetchUserInfo(context)&#10;                                loggingIn = false&#10;                                LoginStateRepository.setLoggedIn(context, true)&#10;                                Toast.makeText(context, &quot;Login successful!&quot;, Toast.LENGTH_SHORT).show()&#10;                            }&#10;                        },&#10;                        onAuthError = {&#10;                            loggingIn = false&#10;                            Toast.makeText(context, &quot;Login failed&quot;, Toast.LENGTH_SHORT).show()&#10;                        }&#10;                    )&#10;                }&#10;&#10;                AuthState.LoggedIn -&gt; {&#10;&#10;                    LaunchedEffect(Unit) {&#10;                        AlarmScheduler.ensureAlarmScheduled(context, 0L)&#10;                    }&#10;&#10;                    LoggedInScreen(&#10;                        modifier = Modifier.padding(innerPadding),&#10;                        onLogout = {&#10;                            scope.launch {&#10;                                logOut(context)&#10;                            }&#10;                            Toast.makeText(context, &quot;Logged out&quot;, Toast.LENGTH_SHORT).show()&#10;                        }&#10;                    )&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    @Composable&#10;    fun LoginButton(&#10;        modifier: Modifier = Modifier,&#10;        onLoginClick: () -&gt; Unit&#10;    ) {&#10;        Box(&#10;            modifier = modifier.fillMaxSize(),&#10;            contentAlignment = Alignment.Center&#10;        ) {&#10;            Button(onClick = onLoginClick) {&#10;                Text(text = &quot;Log in&quot;)&#10;            }&#10;        }&#10;    }&#10;&#10;    @SuppressLint(&quot;SetJavaScriptEnabled&quot;)&#10;    @Composable&#10;    fun AuthWebView(&#10;        modifier: Modifier = Modifier,&#10;        onAuthComplete: (Map&lt;String, String&gt;) -&gt; Unit,&#10;        onAuthError: () -&gt; Unit&#10;    ) {&#10;        AndroidView(&#10;            modifier = modifier.fillMaxSize(),&#10;            factory = { context -&gt;&#10;                WebView(context).apply {&#10;&#10;&#10;                    val cookieManager = CookieManager.getInstance()&#10;                    cookieManager.setAcceptCookie(true)&#10;                    cookieManager.setAcceptThirdPartyCookies(this, true)&#10;&#10;                    settings.apply {&#10;                        javaScriptEnabled = true&#10;                        domStorageEnabled = true&#10;                    }&#10;&#10;                    webViewClient = MyWebViewClient(&#10;                        { onSuccess, onError -&gt;&#10;                            extractAndReturnCookies( onSuccess, onError)&#10;                        },&#10;                        onAuthComplete,&#10;                        onAuthError&#10;                    )&#10;&#10;                    loadUrl(LOGIN_URL)&#10;                }&#10;            }&#10;        )&#10;    }&#10;&#10;    @Composable&#10;    fun LoggedInScreen(&#10;        modifier: Modifier = Modifier,&#10;        onLogout: () -&gt; Unit&#10;    ) {&#10;        val context = LocalContext.current&#10;        val scope = rememberCoroutineScope()&#10;&#10;        // Read first name from DataStore&#10;        val firstName by context.userInfoDataStore.data&#10;            .map { preferences -&gt; preferences[FIRST_NAME_KEY] ?: &quot;&quot; }&#10;            .collectAsState(initial = &quot;&quot;)&#10;&#10;        // Use collectAsState to automatically update when new entries are added&#10;        val logEntries by LogEntryManager.loadLogEntriesFlow(context).collectAsState(initial = emptyList())&#10;&#10;        Column(&#10;            modifier = modifier.fillMaxSize().padding(16.dp)&#10;        ) {&#10;            // Welcome message with first name&#10;            if (firstName.isNotEmpty()) {&#10;                Text(&#10;                    text = &quot;Welcome, $firstName!&quot;,&#10;                    style = MaterialTheme.typography.headlineMedium,&#10;                    color = MaterialTheme.colorScheme.primary,&#10;                    modifier = Modifier.padding(bottom = 16.dp)&#10;                )&#10;            }&#10;&#10;            // Header row with title and action buttons&#10;            Row(&#10;                modifier = Modifier.fillMaxWidth(),&#10;                horizontalArrangement = Arrangement.SpaceBetween,&#10;                verticalAlignment = Alignment.CenterVertically&#10;            ) {&#10;                Text(&#10;                    text = &quot;Data Access Monitor&quot;,&#10;                    style = MaterialTheme.typography.headlineSmall&#10;                )&#10;&#10;                Row(&#10;                    horizontalArrangement = Arrangement.spacedBy(8.dp),&#10;                    verticalAlignment = Alignment.CenterVertically&#10;                ) {&#10;                    // Test API button - smaller and moved to header&#10;                    // Comment out the test button since it's for testing only&#10;                    /*&#10;                    OutlinedButton(&#10;                        onClick = {&#10;                            scope.launch {&#10;                                getURL(context, API_TEST_URL)&#10;                            }&#10;                        }&#10;                    ) {&#10;                        Text(text = &quot;Test&quot;, style = MaterialTheme.typography.bodySmall)&#10;                    }&#10;                    */&#10;&#10;                    Button(onClick = onLogout) {&#10;                        Text(text = &quot;Log out&quot;)&#10;                    }&#10;                }&#10;            }&#10;&#10;            Spacer(modifier = Modifier.height(24.dp))&#10;&#10;            // Log entries section with improved spacing&#10;            Row(&#10;                modifier = Modifier.fillMaxWidth(),&#10;                horizontalArrangement = Arrangement.SpaceBetween,&#10;                verticalAlignment = Alignment.CenterVertically&#10;            ) {&#10;                Text(&#10;                    text = &quot;Recent Activity&quot;,&#10;                    style = MaterialTheme.typography.titleLarge&#10;                )&#10;                Text(&#10;                    text = &quot;${logEntries.size} entries&quot;,&#10;                    style = MaterialTheme.typography.bodyMedium,&#10;                    color = MaterialTheme.colorScheme.onSurfaceVariant&#10;                )&#10;            }&#10;&#10;            Spacer(modifier = Modifier.height(16.dp))&#10;&#10;            // Scrollable list of log entries&#10;            if (logEntries.isEmpty()) {&#10;                Card(&#10;                    modifier = Modifier.fillMaxWidth(),&#10;                    colors = CardDefaults.cardColors(&#10;                        containerColor = MaterialTheme.colorScheme.surfaceVariant&#10;                    )&#10;                ) {&#10;                    Box(&#10;                        modifier = Modifier&#10;                            .fillMaxWidth()&#10;                            .padding(32.dp),&#10;                        contentAlignment = Alignment.Center&#10;                    ) {&#10;                        Column(&#10;                            horizontalAlignment = Alignment.CenterHorizontally,&#10;                            verticalArrangement = Arrangement.spacedBy(8.dp)&#10;                        ) {&#10;                            Text(&#10;                                text = &quot;No activity yet&quot;,&#10;                                style = MaterialTheme.typography.titleMedium,&#10;                                color = MaterialTheme.colorScheme.onSurfaceVariant&#10;                            )&#10;                            Text(&#10;                                text = &quot;Data access logs will appear here&quot;,&#10;                                style = MaterialTheme.typography.bodyMedium,&#10;                                color = MaterialTheme.colorScheme.onSurfaceVariant&#10;                            )&#10;                        }&#10;                    }&#10;                }&#10;            } else {&#10;                LazyColumn(&#10;                    modifier = Modifier.fillMaxSize(),&#10;                    verticalArrangement = Arrangement.spacedBy(12.dp)&#10;                ) {&#10;                    items(logEntries.size) { index -&gt;&#10;                        LogEntryItem(logEntry = logEntries[index])&#10;                    }&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    @Composable&#10;    fun LogEntryItem(logEntry: LogEntryProto) {&#10;        Card(&#10;            modifier = Modifier.fillMaxWidth(),&#10;            elevation = CardDefaults.cardElevation(defaultElevation = 4.dp)&#10;        ) {&#10;            Column(&#10;                modifier = Modifier.padding(16.dp)&#10;            ) {&#10;                Row(&#10;                    modifier = Modifier.fillMaxWidth(),&#10;                    horizontalArrangement = Arrangement.SpaceBetween&#10;                ) {&#10;                    Text(&#10;                        text = logEntry.infoSystem,&#10;                        style = MaterialTheme.typography.titleSmall,&#10;                        color = MaterialTheme.colorScheme.primary&#10;                    )&#10;                    Text(&#10;                        text = LogEntryManager.formatDisplayTime(logEntry.timestamp),&#10;                        style = MaterialTheme.typography.bodySmall,&#10;                        color = MaterialTheme.colorScheme.onSurfaceVariant&#10;                    )&#10;                }&#10;&#10;                Spacer(modifier = Modifier.height(4.dp))&#10;&#10;                Text(&#10;                    text = logEntry.receiver,&#10;                    style = MaterialTheme.typography.bodyMedium&#10;                )&#10;&#10;                Spacer(modifier = Modifier.height(4.dp))&#10;&#10;                Text(&#10;                    text = logEntry.action,&#10;                    style = MaterialTheme.typography.bodySmall,&#10;                    color = MaterialTheme.colorScheme.onSurfaceVariant&#10;                )&#10;            }&#10;        }&#10;    }&#10;&#10;&#10;    private fun extractAndReturnCookies(&#10;        onSuccess: (Map&lt;String, String&gt;) -&gt; Unit,&#10;        onError: () -&gt; Unit&#10;    ) {&#10;&#10;        val cookieManager = CookieManager.getInstance()&#10;&#10;        val domains = listOf(&#10;            &quot;https://www.eesti.ee&quot;,&#10;        )&#10;&#10;        val allCookies = mutableMapOf&lt;String, String&gt;()&#10;&#10;        domains.forEach { domain -&gt;&#10;            val cookies = cookieManager.getCookie(domain)&#10;            cookies?.let { cookieString -&gt;&#10;                if (cookieString.isNotEmpty()) {&#10;                    Log.d(TAG, &quot;Cookies from $domain: $cookieString&quot;)&#10;                    val cookieMap = cookieStringToMap(cookieString)&#10;                    allCookies.putAll(cookieMap)&#10;                }&#10;            }&#10;        }&#10;&#10;        Log.d(TAG, &quot;Total extracted cookies: ${allCookies.size}&quot;)&#10;        if (allCookies.isNotEmpty()) {&#10;            onSuccess(allCookies)&#10;        } else {&#10;            onError()&#10;        }&#10;    }&#10;}&#10;&#10;enum class AuthState {&#10;    LoggedOut,&#10;    LoggingIn,&#10;    LoggedIn&#10;}" />
              <option name="updatedContent" value="package com.arkadst.dataaccessnotifier&#10;&#10;import android.annotation.SuppressLint&#10;import android.content.Context&#10;import android.os.Bundle&#10;import android.util.Log&#10;import android.webkit.CookieManager&#10;import android.webkit.WebView&#10;import android.widget.Toast&#10;import androidx.activity.ComponentActivity&#10;import androidx.activity.compose.setContent&#10;import androidx.activity.enableEdgeToEdge&#10;import androidx.activity.result.ActivityResultLauncher&#10;import androidx.activity.result.contract.ActivityResultContracts&#10;import androidx.compose.foundation.layout.*&#10;import androidx.compose.foundation.lazy.LazyColumn&#10;import androidx.compose.material3.*&#10;import androidx.compose.runtime.*&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.platform.LocalContext&#10;import androidx.compose.ui.unit.dp&#10;import androidx.compose.ui.viewinterop.AndroidView&#10;import com.arkadst.dataaccessnotifier.ui.theme.DataAccessNotifierTheme&#10;import com.arkadst.dataaccessnotifier.Utils.fetchUserInfo&#10;import com.arkadst.dataaccessnotifier.Utils.getURL&#10;import kotlinx.coroutines.launch&#10;import androidx.datastore.preferences.core.edit&#10;import androidx.datastore.preferences.core.stringPreferencesKey&#10;import com.arkadst.dataaccessnotifier.NotificationManager.requestNotificationPermission&#10;import com.arkadst.dataaccessnotifier.Utils.logOut&#10;import com.arkadst.dataaccessnotifier.alarm.AlarmScheduler&#10;import kotlinx.coroutines.flow.map&#10;&#10;const val LOGIN_URL = &quot;https://www.eesti.ee/timur/oauth2/authorization/govsso?callback_url=https://www.eesti.ee/auth/callback&amp;locale=et&quot;&#10;const val SUCCESS_URL = &quot;https://www.eesti.ee/auth/callback&quot;&#10;private const val TAG = &quot;CookieExtraction&quot;&#10;private const val API_TEST_URL = &quot;https://www.eesti.ee/andmejalgija/api/v1/usages?dataSystemCodes=rahvastikuregister&quot;&#10;&#10;class MainActivity : ComponentActivity() {&#10;&#10;    private lateinit var notificationPermissionLauncher: ActivityResultLauncher&lt;String&gt;&#10;    private suspend fun saveCookies(context: Context, cookies: Map&lt;String, String&gt;) {&#10;        context.cookieDataStore.edit { storedCookies -&gt;&#10;            cookies.forEach { (name, value) -&gt;&#10;                storedCookies[stringPreferencesKey(name)] = value&#10;            }&#10;        }&#10;        Log.d(TAG, &quot;Saved ${cookies.size} cookies&quot;)&#10;    }&#10;&#10;&#10;    private fun cookieStringToMap(cookieString: String): Map&lt;String, String&gt;{&#10;        val cookieMap = mutableMapOf&lt;String, String&gt;()&#10;        cookieString.split(&quot;;&quot;).forEach { cookie -&gt;&#10;            val cookiePair = cookie.trim().split(&quot;=&quot;)&#10;            if (cookiePair.size == 2) {&#10;                val cookieName = cookiePair[0].trim()&#10;                cookieMap[cookieName] = cookie&#10;                Log.d(TAG, &quot;Cookie: $cookieName = $cookie&quot;)&#10;            }&#10;        }&#10;        return cookieMap&#10;    }&#10;&#10;&#10;&#10;    override fun onCreate(savedInstanceState: Bundle?) {&#10;        super.onCreate(savedInstanceState)&#10;&#10;        notificationPermissionLauncher = registerForActivityResult(&#10;            ActivityResultContracts.RequestPermission()&#10;        ) { isGranted -&gt;&#10;            if (isGranted) {&#10;                Log.d(TAG, &quot;Notification permission granted&quot;)&#10;                Toast.makeText(this, &quot;Notification permission granted&quot;, Toast.LENGTH_SHORT).show()&#10;            } else {&#10;                Log.d(TAG, &quot;Notification permission denied&quot;)&#10;                Toast.makeText(this, &quot;Notification permission denied. The app won't work without it.&quot;, Toast.LENGTH_SHORT).show()&#10;                this.finishAffinity()&#10;            }&#10;        }&#10;&#10;        LoginStateRepository.init(this)&#10;        WebView.setWebContentsDebuggingEnabled(true)&#10;        enableEdgeToEdge()&#10;        setContent {&#10;            DataAccessNotifierTheme {&#10;                AuthScreen()&#10;            }&#10;        }&#10;    }&#10;&#10;    override fun onResume() {&#10;        super.onResume()&#10;        if (!AlarmScheduler.requestExactAlarmPermissionIfNeeded(this)){&#10;            requestNotificationPermission(this, notificationPermissionLauncher)&#10;        }&#10;    }&#10;&#10;    @Composable&#10;    fun AuthScreen() {&#10;&#10;        val context = LocalContext.current&#10;        val scope = rememberCoroutineScope()&#10;        val isLoggedIn by LoginStateRepository.isLoggedIn.collectAsState()&#10;        var loggingIn by remember { mutableStateOf(false) }&#10;        val authState = when {&#10;            loggingIn -&gt; AuthState.LoggingIn&#10;            isLoggedIn -&gt; AuthState.LoggedIn&#10;            else -&gt; AuthState.LoggedOut&#10;        }&#10;&#10;        Scaffold(modifier = Modifier.fillMaxSize()) { innerPadding -&gt;&#10;            when (authState) {&#10;                AuthState.LoggedOut -&gt; {&#10;                    LoginButton(&#10;                        modifier = Modifier.padding(innerPadding),&#10;                        onLoginClick = {&#10;                            Toast.makeText(context, &quot;Logging in...&quot;, Toast.LENGTH_SHORT).show()&#10;                            loggingIn = true&#10;                        }&#10;                    )&#10;                }&#10;&#10;                AuthState.LoggingIn -&gt; {&#10;&#10;                    AuthWebView(&#10;                        modifier = Modifier.padding(innerPadding),&#10;                        onAuthComplete = { cookies -&gt;&#10;                            scope.launch {&#10;                                //saveCookies(context, cookies)&#10;                                fetchUserInfo(context)&#10;                                loggingIn = false&#10;                                LoginStateRepository.setLoggedIn(context, true)&#10;                                Toast.makeText(context, &quot;Login successful!&quot;, Toast.LENGTH_SHORT).show()&#10;                            }&#10;                        },&#10;                        onAuthError = {&#10;                            loggingIn = false&#10;                            Toast.makeText(context, &quot;Login failed&quot;, Toast.LENGTH_SHORT).show()&#10;                        }&#10;                    )&#10;                }&#10;&#10;                AuthState.LoggedIn -&gt; {&#10;&#10;                    LaunchedEffect(Unit) {&#10;                        AlarmScheduler.ensureAlarmScheduled(context, 0L)&#10;                    }&#10;&#10;                    LoggedInScreen(&#10;                        modifier = Modifier.padding(innerPadding),&#10;                        onLogout = {&#10;                            scope.launch {&#10;                                logOut(context)&#10;                            }&#10;                            Toast.makeText(context, &quot;Logged out&quot;, Toast.LENGTH_SHORT).show()&#10;                        }&#10;                    )&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    @Composable&#10;    fun LoginButton(&#10;        modifier: Modifier = Modifier,&#10;        onLoginClick: () -&gt; Unit&#10;    ) {&#10;        Box(&#10;            modifier = modifier.fillMaxSize(),&#10;            contentAlignment = Alignment.Center&#10;        ) {&#10;            Button(onClick = onLoginClick) {&#10;                Text(text = &quot;Log in&quot;)&#10;            }&#10;        }&#10;    }&#10;&#10;    @SuppressLint(&quot;SetJavaScriptEnabled&quot;)&#10;    @Composable&#10;    fun AuthWebView(&#10;        modifier: Modifier = Modifier,&#10;        onAuthComplete: (Map&lt;String, String&gt;) -&gt; Unit,&#10;        onAuthError: () -&gt; Unit&#10;    ) {&#10;        AndroidView(&#10;            modifier = modifier.fillMaxSize(),&#10;            factory = { context -&gt;&#10;                WebView(context).apply {&#10;&#10;&#10;                    val cookieManager = CookieManager.getInstance()&#10;                    cookieManager.setAcceptCookie(true)&#10;                    cookieManager.setAcceptThirdPartyCookies(this, true)&#10;&#10;                    settings.apply {&#10;                        javaScriptEnabled = true&#10;                        domStorageEnabled = true&#10;                    }&#10;&#10;                    webViewClient = MyWebViewClient(&#10;                        { onSuccess, onError -&gt;&#10;                            extractAndReturnCookies( onSuccess, onError)&#10;                        },&#10;                        onAuthComplete,&#10;                        onAuthError&#10;                    )&#10;&#10;                    loadUrl(LOGIN_URL)&#10;                }&#10;            }&#10;        )&#10;    }&#10;&#10;    @Composable&#10;    fun LoggedInScreen(&#10;        modifier: Modifier = Modifier,&#10;        onLogout: () -&gt; Unit&#10;    ) {&#10;        val context = LocalContext.current&#10;        val scope = rememberCoroutineScope()&#10;&#10;        // Read first name from DataStore - fixed to use remember to avoid recomposition issues&#10;        val firstNameFlow = remember {&#10;            context.userInfoDataStore.data.map { preferences -&gt; &#10;                preferences[FIRST_NAME_KEY] ?: &quot;&quot; &#10;            }&#10;        }&#10;        val firstName by firstNameFlow.collectAsState(initial = &quot;&quot;)&#10;&#10;        // Use collectAsState to automatically update when new entries are added&#10;        val logEntries by LogEntryManager.loadLogEntriesFlow(context).collectAsState(initial = emptyList())&#10;&#10;        Column(&#10;            modifier = modifier.fillMaxSize().padding(16.dp)&#10;        ) {&#10;            // Welcome message with first name&#10;            if (firstName.isNotEmpty()) {&#10;                Text(&#10;                    text = &quot;Welcome, $firstName!&quot;,&#10;                    style = MaterialTheme.typography.headlineMedium,&#10;                    color = MaterialTheme.colorScheme.primary,&#10;                    modifier = Modifier.padding(bottom = 16.dp)&#10;                )&#10;            }&#10;&#10;            // Header row with title and action buttons&#10;            Row(&#10;                modifier = Modifier.fillMaxWidth(),&#10;                horizontalArrangement = Arrangement.SpaceBetween,&#10;                verticalAlignment = Alignment.CenterVertically&#10;            ) {&#10;                Text(&#10;                    text = &quot;Data Access Monitor&quot;,&#10;                    style = MaterialTheme.typography.headlineSmall&#10;                )&#10;&#10;                Row(&#10;                    horizontalArrangement = Arrangement.spacedBy(8.dp),&#10;                    verticalAlignment = Alignment.CenterVertically&#10;                ) {&#10;                    // Test API button - smaller and moved to header&#10;                    // Comment out the test button since it's for testing only&#10;                    /*&#10;                    OutlinedButton(&#10;                        onClick = {&#10;                            scope.launch {&#10;                                getURL(context, API_TEST_URL)&#10;                            }&#10;                        }&#10;                    ) {&#10;                        Text(text = &quot;Test&quot;, style = MaterialTheme.typography.bodySmall)&#10;                    }&#10;                    */&#10;&#10;                    Button(onClick = onLogout) {&#10;                        Text(text = &quot;Log out&quot;)&#10;                    }&#10;                }&#10;            }&#10;&#10;            Spacer(modifier = Modifier.height(24.dp))&#10;&#10;            // Log entries section with improved spacing&#10;            Row(&#10;                modifier = Modifier.fillMaxWidth(),&#10;                horizontalArrangement = Arrangement.SpaceBetween,&#10;                verticalAlignment = Alignment.CenterVertically&#10;            ) {&#10;                Text(&#10;                    text = &quot;Recent Activity&quot;,&#10;                    style = MaterialTheme.typography.titleLarge&#10;                )&#10;                Text(&#10;                    text = &quot;${logEntries.size} entries&quot;,&#10;                    style = MaterialTheme.typography.bodyMedium,&#10;                    color = MaterialTheme.colorScheme.onSurfaceVariant&#10;                )&#10;            }&#10;&#10;            Spacer(modifier = Modifier.height(16.dp))&#10;&#10;            // Scrollable list of log entries&#10;            if (logEntries.isEmpty()) {&#10;                Card(&#10;                    modifier = Modifier.fillMaxWidth(),&#10;                    colors = CardDefaults.cardColors(&#10;                        containerColor = MaterialTheme.colorScheme.surfaceVariant&#10;                    )&#10;                ) {&#10;                    Box(&#10;                        modifier = Modifier&#10;                            .fillMaxWidth()&#10;                            .padding(32.dp),&#10;                        contentAlignment = Alignment.Center&#10;                    ) {&#10;                        Column(&#10;                            horizontalAlignment = Alignment.CenterHorizontally,&#10;                            verticalArrangement = Arrangement.spacedBy(8.dp)&#10;                        ) {&#10;                            Text(&#10;                                text = &quot;No activity yet&quot;,&#10;                                style = MaterialTheme.typography.titleMedium,&#10;                                color = MaterialTheme.colorScheme.onSurfaceVariant&#10;                            )&#10;                            Text(&#10;                                text = &quot;Data access logs will appear here&quot;,&#10;                                style = MaterialTheme.typography.bodyMedium,&#10;                                color = MaterialTheme.colorScheme.onSurfaceVariant&#10;                            )&#10;                        }&#10;                    }&#10;                }&#10;            } else {&#10;                LazyColumn(&#10;                    modifier = Modifier.fillMaxSize(),&#10;                    verticalArrangement = Arrangement.spacedBy(12.dp)&#10;                ) {&#10;                    items(logEntries.size) { index -&gt;&#10;                        LogEntryItem(logEntry = logEntries[index])&#10;                    }&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    @Composable&#10;    fun LogEntryItem(logEntry: LogEntryProto) {&#10;        Card(&#10;            modifier = Modifier.fillMaxWidth(),&#10;            elevation = CardDefaults.cardElevation(defaultElevation = 4.dp)&#10;        ) {&#10;            Column(&#10;                modifier = Modifier.padding(16.dp)&#10;            ) {&#10;                Row(&#10;                    modifier = Modifier.fillMaxWidth(),&#10;                    horizontalArrangement = Arrangement.SpaceBetween&#10;                ) {&#10;                    Text(&#10;                        text = logEntry.infoSystem,&#10;                        style = MaterialTheme.typography.titleSmall,&#10;                        color = MaterialTheme.colorScheme.primary&#10;                    )&#10;                    Text(&#10;                        text = LogEntryManager.formatDisplayTime(logEntry.timestamp),&#10;                        style = MaterialTheme.typography.bodySmall,&#10;                        color = MaterialTheme.colorScheme.onSurfaceVariant&#10;                    )&#10;                }&#10;&#10;                Spacer(modifier = Modifier.height(4.dp))&#10;&#10;                Text(&#10;                    text = logEntry.receiver,&#10;                    style = MaterialTheme.typography.bodyMedium&#10;                )&#10;&#10;                Spacer(modifier = Modifier.height(4.dp))&#10;&#10;                Text(&#10;                    text = logEntry.action,&#10;                    style = MaterialTheme.typography.bodySmall,&#10;                    color = MaterialTheme.colorScheme.onSurfaceVariant&#10;                )&#10;            }&#10;        }&#10;    }&#10;&#10;&#10;    private fun extractAndReturnCookies(&#10;        onSuccess: (Map&lt;String, String&gt;) -&gt; Unit,&#10;        onError: () -&gt; Unit&#10;    ) {&#10;&#10;        val cookieManager = CookieManager.getInstance()&#10;&#10;        val domains = listOf(&#10;            &quot;https://www.eesti.ee&quot;,&#10;        )&#10;&#10;        val allCookies = mutableMapOf&lt;String, String&gt;()&#10;&#10;        domains.forEach { domain -&gt;&#10;            val cookies = cookieManager.getCookie(domain)&#10;            cookies?.let { cookieString -&gt;&#10;                if (cookieString.isNotEmpty()) {&#10;                    Log.d(TAG, &quot;Cookies from $domain: $cookieString&quot;)&#10;                    val cookieMap = cookieStringToMap(cookieString)&#10;                    allCookies.putAll(cookieMap)&#10;                }&#10;            }&#10;        }&#10;&#10;        Log.d(TAG, &quot;Total extracted cookies: ${allCookies.size}&quot;)&#10;        if (allCookies.isNotEmpty()) {&#10;            onSuccess(allCookies)&#10;        } else {&#10;            onError()&#10;        }&#10;    }&#10;}&#10;&#10;enum class AuthState {&#10;    LoggedOut,&#10;    LoggingIn,&#10;    LoggedIn&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/arkadst/dataaccessnotifier/StoredAccessLogManager.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/arkadst/dataaccessnotifier/StoredAccessLogManager.kt" />
              <option name="originalContent" value="package com.arkadst.dataaccessnotifier&#10;&#10;import android.content.Context&#10;import kotlinx.coroutines.flow.first&#10;&#10;object StoredAccessLogManager {&#10;    &#10;    suspend fun addAccessLog(context: Context, logEntry: LogEntry) {&#10;        context.accessLogsDataStore.updateData { currentLogs -&gt;&#10;            val existingHashes = currentLogs.entriesList.map { it.contentHash }.toSet()&#10;            val hash = LogEntryManager.generateContentHash(logEntry)&#10;            &#10;            val builder = currentLogs.toBuilder()&#10;            if (!existingHashes.contains(hash)) {&#10;                val protoEntry = LogEntryProto.newBuilder()&#10;                    .setTimestamp(logEntry.timestamp)&#10;                    .setReceiver(logEntry.receiver)&#10;                    .setInfoSystem(logEntry.infoSystem)&#10;                    .setAction(logEntry.action)&#10;                    .setContentHash(hash)&#10;                    .build()&#10;                    &#10;                builder.addEntries(protoEntry)&#10;            }&#10;            &#10;            builder.build()&#10;        }&#10;    }&#10;&#10;    suspend fun hasAccessLog(context: Context, logEntry: LogEntry): Boolean {&#10;        val logs = context.accessLogsDataStore.data.first()&#10;        val hash = LogEntryManager.generateContentHash(logEntry)&#10;        return logs.entriesList.any { it.contentHash == hash }&#10;    }&#10;&#10;    suspend fun getAllAccessLogs(context: Context): List&lt;LogEntry&gt; {&#10;        val logs = context.accessLogsDataStore.data.first()&#10;        return logs.entriesList.map { proto -&gt;&#10;            LogEntry(&#10;                timestamp = proto.timestamp,&#10;                receiver = proto.receiver,&#10;                infoSystem = proto.infoSystem,&#10;                action = proto.action&#10;            )&#10;        }.sortedByDescending { it.timestamp }&#10;    }&#10;&#10;    suspend fun clearAccessLogs(context: Context) {&#10;        context.accessLogsDataStore.updateData {&#10;            AccessLogsProto.getDefaultInstance()&#10;        }&#10;    }&#10;    &#10;    suspend fun getAccessLogCount(context: Context): Int {&#10;        val logs = context.accessLogsDataStore.data.first()&#10;        return logs.entriesCount&#10;    }&#10;}" />
              <option name="updatedContent" value="package com.arkadst.dataaccessnotifier&#10;&#10;import android.content.Context&#10;import kotlinx.coroutines.flow.first&#10;&#10;object StoredAccessLogManager {&#10;    &#10;    suspend fun addAccessLog(context: Context, logEntry: LogEntryProto) {&#10;        context.accessLogsDataStore.updateData { currentLogs -&gt;&#10;            val existingHashes = currentLogs.entriesList.map { it.contentHash }.toSet()&#10;            &#10;            val builder = currentLogs.toBuilder()&#10;            if (!existingHashes.contains(logEntry.contentHash)) {&#10;                builder.addEntries(logEntry)&#10;            }&#10;            &#10;            builder.build()&#10;        }&#10;    }&#10;&#10;    suspend fun hasAccessLog(context: Context, logEntry: LogEntryProto): Boolean {&#10;        val logs = context.accessLogsDataStore.data.first()&#10;        return logs.entriesList.any { it.contentHash == logEntry.contentHash }&#10;    }&#10;&#10;    suspend fun getAllAccessLogs(context: Context): List&lt;LogEntryProto&gt; {&#10;        val logs = context.accessLogsDataStore.data.first()&#10;        return logs.entriesList.sortedByDescending { it.timestamp }&#10;    }&#10;&#10;    suspend fun clearAccessLogs(context: Context) {&#10;        context.accessLogsDataStore.updateData {&#10;            AccessLogsProto.getDefaultInstance()&#10;        }&#10;    }&#10;    &#10;    suspend fun getAccessLogCount(context: Context): Int {&#10;        val logs = context.accessLogsDataStore.data.first()&#10;        return logs.entriesCount&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/gradle/libs.versions.toml">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/gradle/libs.versions.toml" />
              <option name="originalContent" value="[versions]&#10;agp = &quot;8.11.1&quot;&#10;kotlin = &quot;2.2.0&quot;&#10;coreKtx = &quot;1.16.0&quot;&#10;junit = &quot;4.13.2&quot;&#10;junitVersion = &quot;1.2.1&quot;&#10;espressoCore = &quot;3.6.1&quot;&#10;lifecycleRuntimeKtx = &quot;2.9.2&quot;&#10;activityCompose = &quot;1.10.1&quot;&#10;composeBom = &quot;2025.07.00&quot;&#10;okhttp = &quot;5.1.0&quot;&#10;workRuntimeKtx = &quot;2.10.2&quot;&#10;kotlinxSerialization = &quot;1.9.0&quot;&#10;kotlinxCoroutines = &quot;1.9.0&quot;&#10;preferencesDataStore = &quot;1.1.7&quot;&#10;protoDataStore = &quot;1.1.7&quot;&#10;protoBuf = &quot;4.31.1&quot;&#10;protoBufGradle = &quot;0.9.5&quot;&#10;&#10;[libraries]&#10;androidx-core-ktx = { group = &quot;androidx.core&quot;, name = &quot;core-ktx&quot;, version.ref = &quot;coreKtx&quot; }&#10;junit = { group = &quot;junit&quot;, name = &quot;junit&quot;, version.ref = &quot;junit&quot; }&#10;androidx-junit = { group = &quot;androidx.test.ext&quot;, name = &quot;junit&quot;, version.ref = &quot;junitVersion&quot; }&#10;androidx-espresso-core = { group = &quot;androidx.test.espresso&quot;, name = &quot;espresso-core&quot;, version.ref = &quot;espressoCore&quot; }&#10;androidx-lifecycle-runtime-ktx = { group = &quot;androidx.lifecycle&quot;, name = &quot;lifecycle-runtime-ktx&quot;, version.ref = &quot;lifecycleRuntimeKtx&quot; }&#10;androidx-activity-compose = { group = &quot;androidx.activity&quot;, name = &quot;activity-compose&quot;, version.ref = &quot;activityCompose&quot; }&#10;androidx-compose-bom = { group = &quot;androidx.compose&quot;, name = &quot;compose-bom&quot;, version.ref = &quot;composeBom&quot; }&#10;androidx-ui = { group = &quot;androidx.compose.ui&quot;, name = &quot;ui&quot; }&#10;androidx-ui-graphics = { group = &quot;androidx.compose.ui&quot;, name = &quot;ui-graphics&quot; }&#10;androidx-ui-tooling = { group = &quot;androidx.compose.ui&quot;, name = &quot;ui-tooling&quot; }&#10;androidx-ui-tooling-preview = { group = &quot;androidx.compose.ui&quot;, name = &quot;ui-tooling-preview&quot; }&#10;androidx-ui-test-manifest = { group = &quot;androidx.compose.ui&quot;, name = &quot;ui-test-manifest&quot; }&#10;androidx-ui-test-junit4 = { group = &quot;androidx.compose.ui&quot;, name = &quot;ui-test-junit4&quot; }&#10;androidx-material3 = { group = &quot;androidx.compose.material3&quot;, name = &quot;material3&quot; }&#10;okhttp = { module = &quot;com.squareup.okhttp3:okhttp&quot;, version.ref = &quot;okhttp&quot; }&#10;androidx-work-runtime-ktx = { group = &quot;androidx.work&quot;, name = &quot;work-runtime-ktx&quot;, version.ref = &quot;workRuntimeKtx&quot; }&#10;kotlinx-serialization-json = { group = &quot;org.jetbrains.kotlinx&quot;, name = &quot;kotlinx-serialization-json&quot;, version.ref = &quot;kotlinxSerialization&quot; }&#10;kotlinx-coroutines-core = { group = &quot;org.jetbrains.kotlinx&quot;, name = &quot;kotlinx-coroutines-core&quot;, version.ref = &quot;kotlinxCoroutines&quot; }&#10;kotlinx-coroutines-android = { group = &quot;org.jetbrains.kotlinx&quot;, name = &quot;kotlinx-coroutines-android&quot;, version.ref = &quot;kotlinxCoroutines&quot; }&#10;datastore-preferences = { group = &quot;androidx.datastore&quot;, name = &quot;datastore-preferences&quot;, version.ref = &quot;preferencesDataStore&quot; }&#10;proto-datastore = { group = &quot;androidx.datastore&quot;, name = &quot;datastore&quot;, version.ref = &quot;protoDataStore&quot; }&#10;protoBuf = { group = &quot;com.google.protobuf&quot;, name = &quot;protobuf-javalite&quot;, version.ref = &quot;protoBuf&quot; }&#10;&#10;[plugins]&#10;android-application = { id = &quot;com.android.application&quot;, version.ref = &quot;agp&quot; }&#10;kotlin-android = { id = &quot;org.jetbrains.kotlin.android&quot;, version.ref = &quot;kotlin&quot; }&#10;kotlin-compose = { id = &quot;org.jetbrains.kotlin.plugin.compose&quot;, version.ref = &quot;kotlin&quot; }&#10;protobuf = { id = &quot;com.google.protobuf&quot;, version.ref = &quot;protoBufGradle&quot; }&#10;" />
              <option name="updatedContent" value="[versions]&#10;agp = &quot;8.11.1&quot;&#10;kotlin = &quot;2.2.0&quot;&#10;coreKtx = &quot;1.16.0&quot;&#10;junit = &quot;4.13.2&quot;&#10;junitVersion = &quot;1.2.1&quot;&#10;espressoCore = &quot;3.6.1&quot;&#10;lifecycleRuntimeKtx = &quot;2.9.2&quot;&#10;activityCompose = &quot;1.10.1&quot;&#10;composeBom = &quot;2025.07.00&quot;&#10;okhttp = &quot;5.1.0&quot;&#10;kotlinxSerialization = &quot;1.9.0&quot;&#10;kotlinxCoroutines = &quot;1.9.0&quot;&#10;preferencesDataStore = &quot;1.1.7&quot;&#10;protoDataStore = &quot;1.1.7&quot;&#10;protoBuf = &quot;4.31.1&quot;&#10;protoBufGradle = &quot;0.9.5&quot;&#10;&#10;[libraries]&#10;androidx-core-ktx = { group = &quot;androidx.core&quot;, name = &quot;core-ktx&quot;, version.ref = &quot;coreKtx&quot; }&#10;junit = { group = &quot;junit&quot;, name = &quot;junit&quot;, version.ref = &quot;junit&quot; }&#10;androidx-junit = { group = &quot;androidx.test.ext&quot;, name = &quot;junit&quot;, version.ref = &quot;junitVersion&quot; }&#10;androidx-espresso-core = { group = &quot;androidx.test.espresso&quot;, name = &quot;espresso-core&quot;, version.ref = &quot;espressoCore&quot; }&#10;androidx-lifecycle-runtime-ktx = { group = &quot;androidx.lifecycle&quot;, name = &quot;lifecycle-runtime-ktx&quot;, version.ref = &quot;lifecycleRuntimeKtx&quot; }&#10;androidx-activity-compose = { group = &quot;androidx.activity&quot;, name = &quot;activity-compose&quot;, version.ref = &quot;activityCompose&quot; }&#10;androidx-compose-bom = { group = &quot;androidx.compose&quot;, name = &quot;compose-bom&quot;, version.ref = &quot;composeBom&quot; }&#10;androidx-ui = { group = &quot;androidx.compose.ui&quot;, name = &quot;ui&quot; }&#10;androidx-ui-graphics = { group = &quot;androidx.compose.ui&quot;, name = &quot;ui-graphics&quot; }&#10;androidx-ui-tooling = { group = &quot;androidx.compose.ui&quot;, name = &quot;ui-tooling&quot; }&#10;androidx-ui-tooling-preview = { group = &quot;androidx.compose.ui&quot;, name = &quot;ui-tooling-preview&quot; }&#10;androidx-ui-test-manifest = { group = &quot;androidx.compose.ui&quot;, name = &quot;ui-test-manifest&quot; }&#10;androidx-ui-test-junit4 = { group = &quot;androidx.compose.ui&quot;, name = &quot;ui-test-junit4&quot; }&#10;androidx-material3 = { group = &quot;androidx.compose.material3&quot;, name = &quot;material3&quot; }&#10;okhttp = { module = &quot;com.squareup.okhttp3:okhttp&quot;, version.ref = &quot;okhttp&quot; }&#10;kotlinx-serialization-json = { group = &quot;org.jetbrains.kotlinx&quot;, name = &quot;kotlinx-serialization-json&quot;, version.ref = &quot;kotlinxSerialization&quot; }&#10;kotlinx-coroutines-core = { group = &quot;org.jetbrains.kotlinx&quot;, name = &quot;kotlinx-coroutines-core&quot;, version.ref = &quot;kotlinxCoroutines&quot; }&#10;kotlinx-coroutines-android = { group = &quot;org.jetbrains.kotlinx&quot;, name = &quot;kotlinx-coroutines-android&quot;, version.ref = &quot;kotlinxCoroutines&quot; }&#10;datastore-preferences = { group = &quot;androidx.datastore&quot;, name = &quot;datastore-preferences&quot;, version.ref = &quot;preferencesDataStore&quot; }&#10;proto-datastore = { group = &quot;androidx.datastore&quot;, name = &quot;datastore&quot;, version.ref = &quot;protoDataStore&quot; }&#10;protoBuf = { group = &quot;com.google.protobuf&quot;, name = &quot;protobuf-javalite&quot;, version.ref = &quot;protoBuf&quot; }&#10;&#10;[plugins]&#10;android-application = { id = &quot;com.android.application&quot;, version.ref = &quot;agp&quot; }&#10;kotlin-android = { id = &quot;org.jetbrains.kotlin.android&quot;, version.ref = &quot;kotlin&quot; }&#10;kotlin-compose = { id = &quot;org.jetbrains.kotlin.plugin.compose&quot;, version.ref = &quot;kotlin&quot; }&#10;protobuf = { id = &quot;com.google.protobuf&quot;, version.ref = &quot;protoBufGradle&quot; }" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>