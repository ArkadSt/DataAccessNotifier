<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/arkadst/dataaccessnotifier/ForegroundServiceMain.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/arkadst/dataaccessnotifier/ForegroundServiceMain.kt" />
              <option name="originalContent" value="package com.arkadst.dataaccessnotifier&#10;&#10;import android.app.Notification&#10;import android.app.NotificationChannel&#10;import android.app.NotificationManager&#10;import android.app.Service&#10;import android.content.Intent&#10;import android.os.Handler&#10;import android.os.IBinder&#10;import android.os.Looper&#10;import android.util.Log&#10;import androidx.core.app.NotificationCompat&#10;import com.arkadst.dataaccessnotifier.NotificationManager.showAccessLogNotification&#10;import com.arkadst.dataaccessnotifier.Utils.getURL&#10;import com.arkadst.dataaccessnotifier.Utils.isFirstUse&#10;import com.arkadst.dataaccessnotifier.Utils.setFirstUse&#10;import com.arkadst.dataaccessnotifier.access_logs.StoredAccessLogManager&#10;import com.arkadst.dataaccessnotifier.alarm.AlarmScheduler&#10;import kotlinx.coroutines.CoroutineScope&#10;import kotlinx.coroutines.Dispatchers&#10;import kotlinx.coroutines.flow.first&#10;import kotlinx.coroutines.launch&#10;import kotlinx.serialization.json.Json.Default.parseToJsonElement&#10;import kotlinx.serialization.json.JsonArray&#10;import kotlinx.serialization.json.JsonElement&#10;import kotlinx.serialization.json.jsonObject&#10;import kotlin.coroutines.resume&#10;import kotlin.coroutines.suspendCoroutine&#10;&#10;&#10;private const val CHANNEL_ID = &quot;JwtExtensionChannel&quot;&#10;private const val NOTIFICATION_ID = 1&#10;private const val TAG = &quot;ForegroundServiceMain&quot;&#10;&#10;class ForegroundServiceMain: Service() {&#10;&#10;    override fun onBind(intent: Intent?): IBinder? = null&#10;&#10;    override fun onCreate() {&#10;        super.onCreate()&#10;        createNotificationChannel()&#10;        startForeground(NOTIFICATION_ID, createNotification())&#10;    }&#10;&#10;    override fun onStartCommand(intent: Intent, flags: Int, startId: Int): Int {&#10;        CoroutineScope(Dispatchers.IO).launch {&#10;            try {&#10;                val maxRetries: Int = intent.getIntExtra(RETRIES_KEY, 3) // Reduced default retries&#10;                var currentRetry = 0&#10;                var success = false&#10;&#10;                while (currentRetry &lt; maxRetries &amp;&amp; !success) {&#10;                    Log.d(TAG, &quot;Attempting JWT session extension, retry: ${currentRetry + 1}/$maxRetries&quot;)&#10;&#10;                    success = extendJwtSession()&#10;&#10;                    if (!success &amp;&amp; currentRetry &lt; maxRetries - 1) {&#10;                        // Exponential backoff: 2^retry * 1000ms (1s, 2s, 4s, etc.)&#10;                        val delayMs = (1 shl currentRetry) * 1000L&#10;                        Log.w(TAG, &quot;Retry ${currentRetry + 1} failed, waiting ${delayMs}ms before next attempt&quot;)&#10;                        kotlinx.coroutines.delay(delayMs)&#10;                    }&#10;                    currentRetry++&#10;                }&#10;&#10;                if (success) {&#10;                    Log.d(TAG, &quot;JWT session extension successful after $currentRetry attempts&quot;)&#10;                    // Poll data tracker after successful JWT extension&#10;                    val dataTrackerSuccess = pollDataTracker()&#10;                    if (dataTrackerSuccess) {&#10;                        Log.d(TAG, &quot;Data tracker poll successful&quot;)&#10;                    } else {&#10;                        Log.e(TAG, &quot;Data tracker poll failed&quot;)&#10;                    }&#10;                    // Schedule next refresh&#10;                    AlarmScheduler.scheduleNextRefresh(applicationContext)&#10;                } else {&#10;                    Log.e(TAG, &quot;JWT session extension failed after $maxRetries attempts&quot;)&#10;                    // Schedule a retry with remaining attempts if any&#10;                    if (maxRetries &gt; 1) {&#10;                        AlarmScheduler.scheduleNextRefresh(applicationContext, retries = maxRetries - 1)&#10;                    }&#10;                }&#10;            } finally {&#10;                stopSelf()&#10;            }&#10;        }&#10;        return START_NOT_STICKY&#10;    }&#10;&#10;    private suspend fun extendJwtSession(): Boolean = suspendCoroutine { continuation -&gt;&#10;        var webView: ReAuthWebViewHeadless? = null&#10;        var hasResumed = false&#10;&#10;        // Create handler for main thread operations&#10;        val mainHandler = Handler(Looper.getMainLooper())&#10;&#10;        // Run WebView creation on main thread&#10;        mainHandler.post {&#10;            // Timeout handler - runs on main thread&#10;            val timeoutHandler = Handler(Looper.getMainLooper())&#10;            val timeoutRunnable = Runnable {&#10;                Log.w(TAG, &quot;WebView authentication timed out after 30 seconds&quot;)&#10;                webView?.cleanup()&#10;                // Resume with false only if not already resumed&#10;                if (!hasResumed) {&#10;                    hasResumed = true&#10;                    continuation.resume(false)&#10;                }&#10;            }&#10;&#10;            try {&#10;                // Schedule timeout (30 seconds)&#10;                timeoutHandler.postDelayed(timeoutRunnable, 30000)&#10;&#10;                // Create WebView on main thread&#10;                webView = ReAuthWebViewHeadless(this@ForegroundServiceMain) { success -&gt;&#10;                    // Cancel timeout since we got a result&#10;                    timeoutHandler.removeCallbacks(timeoutRunnable)&#10;&#10;                    // Resume with the authentication result&#10;                    if (!hasResumed) {&#10;                        hasResumed = true&#10;                        Log.d(TAG, &quot;WebView authentication completed: $success&quot;)&#10;                        continuation.resume(success)&#10;                    }&#10;                }&#10;            } catch (e: Exception) {&#10;                Log.e(TAG, &quot;Error creating WebView&quot;, e)&#10;                timeoutHandler.removeCallbacks(timeoutRunnable)&#10;                if (!hasResumed) {&#10;                    hasResumed = true&#10;                    continuation.resume(false)&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    private suspend fun pollDataTracker() : Boolean {&#10;&#10;            val response = getURL(applicationContext, DATA_TRACKER_API_URL)&#10;            val statusCode = response.first&#10;            if (statusCode == 200) {&#10;                response.second.let { body -&gt;&#10;                    Log.d(TAG, &quot;Data tracker response: $body&quot;)&#10;                    val entries = parseDataTrackerResponseBody(body)&#10;                    Log.d(TAG, &quot;Parsed entries: $entries&quot;)&#10;                    handleParsedEntries(entries)&#10;                }&#10;                return true&#10;            } else {&#10;                Log.e(TAG, &quot;Data tracker API call failed: $statusCode&quot;)&#10;                return false&#10;            }&#10;    }&#10;&#10;    private suspend fun parseDataTrackerResponseBody(body: String) : List&lt;JsonElement&gt; {&#10;        // Implement your parsing logic here&#10;        parseToJsonElement(body).let { jsonElement : JsonElement -&gt;&#10;            jsonElement.jsonObject[&quot;findUsageResponses&quot;]?.let { entries -&gt;&#10;                if (entries is JsonArray) {&#10;                    return entries.filterNot { entry : JsonElement -&gt;&#10;                        val personalCode : String = applicationContext.userInfoDataStore.data.first().asMap()[PERSONAL_CODE_KEY]?.toString()!!&#10;                        val receiver = entry.jsonObject[&quot;receiver&quot;]?.toString()&#10;                        receiver?.contains(personalCode) == true&#10;                    }&#10;                } else {&#10;                    Log.e(TAG, &quot;Expected JsonArray but got ${entries.javaClass}&quot;)&#10;                }&#10;            }&#10;        }&#10;        return emptyList()&#10;    }&#10;&#10;    private suspend fun handleParsedEntries(entries: List&lt;JsonElement&gt;) {&#10;        // Use LogEntryManager to parse entries into LogEntryProto objects&#10;        val parsedEntries = LogEntryManager.parseLogEntries(entries)&#10;&#10;        // Filter out entries that already exist using LogEntryProto objects&#10;        val newEntries = parsedEntries.filterNot { entry -&gt;&#10;            StoredAccessLogManager.hasAccessLog(applicationContext, entry)&#10;        }&#10;&#10;        // Add new entries to storage&#10;        newEntries.forEach { entry -&gt;&#10;            StoredAccessLogManager.addAccessLog(applicationContext, entry)&#10;        }&#10;&#10;        if (newEntries.isEmpty()) {&#10;            Log.d(TAG, &quot;No new entries found&quot;)&#10;        } else {&#10;            Log.d(TAG, &quot;New entries found: ${newEntries.size}&quot;)&#10;        }&#10;&#10;        if (isFirstUse(applicationContext)) {&#10;            setFirstUse(applicationContext, false)&#10;        } else {&#10;            Log.d(TAG, &quot;Not first use, showing notifications for ${newEntries.size} new entries&quot;)&#10;            // Directly use LogEntryProto objects for notifications&#10;            newEntries.forEach { entry -&gt;&#10;                showAccessLogNotification(applicationContext, entry)&#10;            }&#10;        }&#10;    }&#10;&#10;    private fun createNotificationChannel() {&#10;        val channel = NotificationChannel(&#10;            CHANNEL_ID,&#10;            &quot;JWT Extension Service&quot;,&#10;            NotificationManager.IMPORTANCE_LOW&#10;        )&#10;        val manager = getSystemService(NOTIFICATION_SERVICE) as NotificationManager&#10;        manager.createNotificationChannel(channel)&#10;    }&#10;&#10;    private fun createNotification(): Notification {&#10;        return NotificationCompat.Builder(this, CHANNEL_ID)&#10;            .setContentTitle(&quot;JWT Extension Service&quot;)&#10;            .setContentText(&quot;Keeping your session alive&quot;)&#10;            .setSmallIcon(android.R.drawable.ic_dialog_info)&#10;            .build()&#10;    }&#10;&#10;}" />
              <option name="updatedContent" value="package com.arkadst.dataaccessnotifier&#10;&#10;import android.app.Notification&#10;import android.app.NotificationChannel&#10;import android.app.NotificationManager&#10;import android.app.Service&#10;import android.content.Intent&#10;import android.os.Handler&#10;import android.os.IBinder&#10;import android.os.Looper&#10;import android.util.Log&#10;import androidx.core.app.NotificationCompat&#10;import com.arkadst.dataaccessnotifier.NotificationManager.showAccessLogNotification&#10;import com.arkadst.dataaccessnotifier.Utils.getURL&#10;import com.arkadst.dataaccessnotifier.Utils.isFirstUse&#10;import com.arkadst.dataaccessnotifier.Utils.setFirstUse&#10;import com.arkadst.dataaccessnotifier.access_logs.StoredAccessLogManager&#10;import com.arkadst.dataaccessnotifier.alarm.AlarmScheduler&#10;import kotlinx.coroutines.CoroutineScope&#10;import kotlinx.coroutines.Dispatchers&#10;import kotlinx.coroutines.flow.first&#10;import kotlinx.coroutines.launch&#10;import kotlinx.serialization.json.Json.Default.parseToJsonElement&#10;import kotlinx.serialization.json.JsonArray&#10;import kotlinx.serialization.json.JsonElement&#10;import kotlinx.serialization.json.jsonObject&#10;import kotlin.coroutines.resume&#10;import kotlin.coroutines.suspendCoroutine&#10;&#10;&#10;private const val CHANNEL_ID = &quot;JwtExtensionChannel&quot;&#10;private const val NOTIFICATION_ID = 1&#10;private const val TAG = &quot;ForegroundServiceMain&quot;&#10;&#10;class ForegroundServiceMain: Service() {&#10;&#10;    override fun onBind(intent: Intent?): IBinder? = null&#10;&#10;    override fun onCreate() {&#10;        super.onCreate()&#10;        createNotificationChannel()&#10;        startForeground(NOTIFICATION_ID, createNotification())&#10;    }&#10;&#10;    override fun onStartCommand(intent: Intent, flags: Int, startId: Int): Int {&#10;        CoroutineScope(Dispatchers.IO).launch {&#10;            try {&#10;                Log.d(TAG, &quot;Attempting JWT session extension&quot;)&#10;                &#10;                val success = extendJwtSession()&#10;&#10;                if (success) {&#10;                    Log.d(TAG, &quot;JWT session extension successful&quot;)&#10;                    // Poll data tracker after successful JWT extension&#10;                    val dataTrackerSuccess = pollDataTracker()&#10;                    if (dataTrackerSuccess) {&#10;                        Log.d(TAG, &quot;Data tracker poll successful&quot;)&#10;                    } else {&#10;                        Log.e(TAG, &quot;Data tracker poll failed&quot;)&#10;                    }&#10;                    // Schedule next refresh&#10;                    AlarmScheduler.scheduleNextRefresh(applicationContext)&#10;                } else {&#10;                    Log.e(TAG, &quot;JWT session extension failed&quot;)&#10;                    // Let AlarmScheduler handle retries&#10;                    AlarmScheduler.scheduleNextRefresh(applicationContext)&#10;                }&#10;            } finally {&#10;                stopSelf()&#10;            }&#10;        }&#10;        return START_NOT_STICKY&#10;    }&#10;&#10;    private suspend fun extendJwtSession(): Boolean = suspendCoroutine { continuation -&gt;&#10;        var webView: ReAuthWebViewHeadless? = null&#10;        var hasResumed = false&#10;&#10;        // Create handler for main thread operations&#10;        val mainHandler = Handler(Looper.getMainLooper())&#10;&#10;        // Run WebView creation on main thread&#10;        mainHandler.post {&#10;            // Timeout handler - runs on main thread&#10;            val timeoutHandler = Handler(Looper.getMainLooper())&#10;            val timeoutRunnable = Runnable {&#10;                Log.w(TAG, &quot;WebView authentication timed out after 30 seconds&quot;)&#10;                webView?.cleanup()&#10;                // Resume with false only if not already resumed&#10;                if (!hasResumed) {&#10;                    hasResumed = true&#10;                    continuation.resume(false)&#10;                }&#10;            }&#10;&#10;            try {&#10;                // Schedule timeout (30 seconds)&#10;                timeoutHandler.postDelayed(timeoutRunnable, 30000)&#10;&#10;                // Create WebView on main thread&#10;                webView = ReAuthWebViewHeadless(this@ForegroundServiceMain) { success -&gt;&#10;                    // Cancel timeout since we got a result&#10;                    timeoutHandler.removeCallbacks(timeoutRunnable)&#10;&#10;                    // Resume with the authentication result&#10;                    if (!hasResumed) {&#10;                        hasResumed = true&#10;                        Log.d(TAG, &quot;WebView authentication completed: $success&quot;)&#10;                        continuation.resume(success)&#10;                    }&#10;                }&#10;            } catch (e: Exception) {&#10;                Log.e(TAG, &quot;Error creating WebView&quot;, e)&#10;                timeoutHandler.removeCallbacks(timeoutRunnable)&#10;                if (!hasResumed) {&#10;                    hasResumed = true&#10;                    continuation.resume(false)&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    private suspend fun pollDataTracker() : Boolean {&#10;&#10;            val response = getURL(applicationContext, DATA_TRACKER_API_URL)&#10;            val statusCode = response.first&#10;            if (statusCode == 200) {&#10;                response.second.let { body -&gt;&#10;                    Log.d(TAG, &quot;Data tracker response: $body&quot;)&#10;                    val entries = parseDataTrackerResponseBody(body)&#10;                    Log.d(TAG, &quot;Parsed entries: $entries&quot;)&#10;                    handleParsedEntries(entries)&#10;                }&#10;                return true&#10;            } else {&#10;                Log.e(TAG, &quot;Data tracker API call failed: $statusCode&quot;)&#10;                return false&#10;            }&#10;    }&#10;&#10;    private suspend fun parseDataTrackerResponseBody(body: String) : List&lt;JsonElement&gt; {&#10;        // Implement your parsing logic here&#10;        parseToJsonElement(body).let { jsonElement : JsonElement -&gt;&#10;            jsonElement.jsonObject[&quot;findUsageResponses&quot;]?.let { entries -&gt;&#10;                if (entries is JsonArray) {&#10;                    return entries.filterNot { entry : JsonElement -&gt;&#10;                        val personalCode : String = applicationContext.userInfoDataStore.data.first().asMap()[PERSONAL_CODE_KEY]?.toString()!!&#10;                        val receiver = entry.jsonObject[&quot;receiver&quot;]?.toString()&#10;                        receiver?.contains(personalCode) == true&#10;                    }&#10;                } else {&#10;                    Log.e(TAG, &quot;Expected JsonArray but got ${entries.javaClass}&quot;)&#10;                }&#10;            }&#10;        }&#10;        return emptyList()&#10;    }&#10;&#10;    private suspend fun handleParsedEntries(entries: List&lt;JsonElement&gt;) {&#10;        // Use LogEntryManager to parse entries into LogEntryProto objects&#10;        val parsedEntries = LogEntryManager.parseLogEntries(entries)&#10;&#10;        // Filter out entries that already exist using LogEntryProto objects&#10;        val newEntries = parsedEntries.filterNot { entry -&gt;&#10;            StoredAccessLogManager.hasAccessLog(applicationContext, entry)&#10;        }&#10;&#10;        // Add new entries to storage&#10;        newEntries.forEach { entry -&gt;&#10;            StoredAccessLogManager.addAccessLog(applicationContext, entry)&#10;        }&#10;&#10;        if (newEntries.isEmpty()) {&#10;            Log.d(TAG, &quot;No new entries found&quot;)&#10;        } else {&#10;            Log.d(TAG, &quot;New entries found: ${newEntries.size}&quot;)&#10;        }&#10;&#10;        if (isFirstUse(applicationContext)) {&#10;            setFirstUse(applicationContext, false)&#10;        } else {&#10;            Log.d(TAG, &quot;Not first use, showing notifications for ${newEntries.size} new entries&quot;)&#10;            // Directly use LogEntryProto objects for notifications&#10;            newEntries.forEach { entry -&gt;&#10;                showAccessLogNotification(applicationContext, entry)&#10;            }&#10;        }&#10;    }&#10;&#10;    private fun createNotificationChannel() {&#10;        val channel = NotificationChannel(&#10;            CHANNEL_ID,&#10;            &quot;JWT Extension Service&quot;,&#10;            NotificationManager.IMPORTANCE_LOW&#10;        )&#10;        val manager = getSystemService(NOTIFICATION_SERVICE) as NotificationManager&#10;        manager.createNotificationChannel(channel)&#10;    }&#10;&#10;    private fun createNotification(): Notification {&#10;        return NotificationCompat.Builder(this, CHANNEL_ID)&#10;            .setContentTitle(&quot;JWT Extension Service&quot;)&#10;            .setContentText(&quot;Keeping your session alive&quot;)&#10;            .setSmallIcon(android.R.drawable.ic_dialog_info)&#10;            .build()&#10;    }&#10;&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/arkadst/dataaccessnotifier/LogEntryManager.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/arkadst/dataaccessnotifier/LogEntryManager.kt" />
              <option name="originalContent" value="package com.arkadst.dataaccessnotifier&#10;&#10;import android.content.Context&#10;import android.util.Log&#10;import com.arkadst.dataaccessnotifier.access_logs.StoredAccessLogManager&#10;import kotlinx.coroutines.flow.first&#10;import kotlinx.serialization.json.JsonElement&#10;import kotlinx.serialization.json.jsonObject&#10;import kotlinx.serialization.json.jsonPrimitive&#10;import java.text.SimpleDateFormat&#10;import java.util.*&#10;&#10;object LogEntryManager {&#10;    private const val TAG = &quot;LogEntryManager&quot;&#10;&#10;    /**&#10;     * Parse a JSON element into a LogEntryProto&#10;     */&#10;    fun parseLogEntry(logElement: JsonElement): LogEntryProto {&#10;        val jsonObject = logElement.jsonObject&#10;&#10;        val timestamp = jsonObject[&quot;logTime&quot;]?.jsonPrimitive?.content ?: &quot;&quot;&#10;        val receiver = jsonObject[&quot;receiver&quot;]?.jsonPrimitive?.content ?: &quot;&quot;&#10;        val infoSystem = jsonObject[&quot;infoSystemCode&quot;]?.jsonPrimitive?.content ?: &quot;&quot;&#10;        val action = jsonObject[&quot;action&quot;]?.jsonPrimitive?.content ?: &quot;&quot;&#10;&#10;        val hash = generateContentHash(timestamp, receiver, infoSystem, action)&#10;&#10;        return LogEntryProto.newBuilder()&#10;            .setTimestamp(timestamp)&#10;            .setReceiver(receiver)&#10;            .setInfoSystem(infoSystem)&#10;            .setAction(action)&#10;            .setContentHash(hash)&#10;            .build()&#10;    }&#10;&#10;    /**&#10;     * Parse multiple JSON elements into LogEntryProto list&#10;     */&#10;    fun parseLogEntries(logElements: List&lt;JsonElement&gt;): List&lt;LogEntryProto&gt; {&#10;        return logElements.map { parseLogEntry(it) }&#10;    }&#10;&#10;    /**&#10;     * Generate a content hash for deduplication&#10;     */&#10;    fun generateContentHash(timestamp: String, receiver: String, infoSystem: String, action: String): String {&#10;        return &quot;$timestamp|$receiver|$infoSystem|$action&quot;&#10;    }&#10;&#10;    /**&#10;     * Format timestamp for display (includes year)&#10;     */&#10;    fun formatDisplayTime(timestamp: String): String {&#10;        return try {&#10;            val inputFormat = SimpleDateFormat(&quot;yyyy-MM-dd'T'HH:mm:ss&quot;, Locale.getDefault())&#10;            val outputFormat = SimpleDateFormat(&quot;dd.MM.yyyy, HH:mm&quot;, Locale.getDefault())&#10;            val date = inputFormat.parse(timestamp)&#10;            date?.let { outputFormat.format(it) } ?: timestamp&#10;        } catch (_: Exception) {&#10;            timestamp&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Create expanded notification content for an entry&#10;     */&#10;    fun formatExpandedNotification(entry: LogEntryProto): String {&#10;        return &quot; Time: ${formatDisplayTime(entry.timestamp)}\n Receiver: ${entry.receiver}\n System: ${entry.infoSystem}\n Action: ${entry.action}&quot;&#10;    }&#10;&#10;    /**&#10;     * Load log entries from persistent storage&#10;     */&#10;    suspend fun loadLogEntriesFromStorage(context: Context): List&lt;LogEntryProto&gt; {&#10;        return try {&#10;            val accessLogsProto = context.accessLogsDataStore.data.first()&#10;            val entries = accessLogsProto.entriesList&#10;            Log.d(TAG, &quot;Loaded ${entries.size} log entries from storage&quot;)&#10;&#10;            entries.sortedByDescending { it.timestamp } // Most recent first&#10;        } catch (e: Exception) {&#10;            Log.e(TAG, &quot;Failed to load log entries from storage: ${e.message}&quot;, e)&#10;            emptyList()&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Process new log entries - parse and save&#10;     */&#10;//    suspend fun processNewLogEntries(&#10;//        context: Context,&#10;//        logElements: List&lt;JsonElement&gt;,&#10;//        saveToStorage: Boolean = true&#10;//    ): List&lt;LogEntryProto&gt; {&#10;//        val newEntries = parseLogEntries(logElements)&#10;//&#10;//        if (saveToStorage) {&#10;//            // Use StoredAccessLogManager for actual saving&#10;//            newEntries.forEach { entry -&gt;&#10;//                StoredAccessLogManager.addAccessLog(context, entry)&#10;//            }&#10;//        }&#10;//&#10;//        Log.d(TAG, &quot;Processed ${newEntries.size} new log entries&quot;)&#10;//        return newEntries&#10;//    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.arkadst.dataaccessnotifier&#10;&#10;import android.content.Context&#10;import android.util.Log&#10;import com.arkadst.dataaccessnotifier.access_logs.StoredAccessLogManager&#10;import kotlinx.coroutines.flow.first&#10;import kotlinx.coroutines.flow.map&#10;import kotlinx.serialization.json.JsonElement&#10;import kotlinx.serialization.json.jsonObject&#10;import kotlinx.serialization.json.jsonPrimitive&#10;import java.text.SimpleDateFormat&#10;import java.util.*&#10;&#10;object LogEntryManager {&#10;    private const val TAG = &quot;LogEntryManager&quot;&#10;&#10;    /**&#10;     * Parse a JSON element into a LogEntryProto&#10;     */&#10;    fun parseLogEntry(logElement: JsonElement): LogEntryProto {&#10;        val jsonObject = logElement.jsonObject&#10;&#10;        val timestamp = jsonObject[&quot;logTime&quot;]?.jsonPrimitive?.content ?: &quot;&quot;&#10;        val receiver = jsonObject[&quot;receiver&quot;]?.jsonPrimitive?.content ?: &quot;&quot;&#10;        val infoSystem = jsonObject[&quot;infoSystemCode&quot;]?.jsonPrimitive?.content ?: &quot;&quot;&#10;        val action = jsonObject[&quot;action&quot;]?.jsonPrimitive?.content ?: &quot;&quot;&#10;&#10;        val hash = generateContentHash(timestamp, receiver, infoSystem, action)&#10;&#10;        return LogEntryProto.newBuilder()&#10;            .setTimestamp(timestamp)&#10;            .setReceiver(receiver)&#10;            .setInfoSystem(infoSystem)&#10;            .setAction(action)&#10;            .setContentHash(hash)&#10;            .build()&#10;    }&#10;&#10;    /**&#10;     * Parse multiple JSON elements into LogEntryProto list&#10;     */&#10;    fun parseLogEntries(logElements: List&lt;JsonElement&gt;): List&lt;LogEntryProto&gt; {&#10;        return logElements.map { parseLogEntry(it) }&#10;    }&#10;&#10;    /**&#10;     * Generate a content hash for deduplication&#10;     */&#10;    fun generateContentHash(timestamp: String, receiver: String, infoSystem: String, action: String): String {&#10;        return &quot;$timestamp|$receiver|$infoSystem|$action&quot;&#10;    }&#10;&#10;    /**&#10;     * Format timestamp for display (includes year)&#10;     */&#10;    fun formatDisplayTime(timestamp: String): String {&#10;        return try {&#10;            val inputFormat = SimpleDateFormat(&quot;yyyy-MM-dd'T'HH:mm:ss&quot;, Locale.getDefault())&#10;            val outputFormat = SimpleDateFormat(&quot;dd.MM.yyyy, HH:mm&quot;, Locale.getDefault())&#10;            val date = inputFormat.parse(timestamp)&#10;            date?.let { outputFormat.format(it) } ?: timestamp&#10;        } catch (_: Exception) {&#10;            timestamp&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Create expanded notification content for an entry&#10;     */&#10;    fun formatExpandedNotification(entry: LogEntryProto): String {&#10;        return &quot; Time: ${formatDisplayTime(entry.timestamp)}\n Receiver: ${entry.receiver}\n System: ${entry.infoSystem}\n Action: ${entry.action}&quot;&#10;    }&#10;&#10;    /**&#10;     * Load log entries from persistent storage as a Flow for reactive updates&#10;     */&#10;    fun loadLogEntriesFlow(context: Context) = context.accessLogsDataStore.data.map { accessLogsProto -&gt;&#10;        accessLogsProto.entriesList.sortedByDescending { it.timestamp }&#10;    }&#10;&#10;    /**&#10;     * Load log entries from persistent storage (one-time read)&#10;     */&#10;    suspend fun loadLogEntriesFromStorage(context: Context): List&lt;LogEntryProto&gt; {&#10;        return try {&#10;            val accessLogsProto = context.accessLogsDataStore.data.first()&#10;            val entries = accessLogsProto.entriesList&#10;            Log.d(TAG, &quot;Loaded ${entries.size} log entries from storage&quot;)&#10;&#10;            entries.sortedByDescending { it.timestamp } // Most recent first&#10;        } catch (e: Exception) {&#10;            Log.e(TAG, &quot;Failed to load log entries from storage: ${e.message}&quot;, e)&#10;            emptyList()&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Process new log entries - parse and save&#10;     */&#10;//    suspend fun processNewLogEntries(&#10;//        context: Context,&#10;//        logElements: List&lt;JsonElement&gt;,&#10;//        saveToStorage: Boolean = true&#10;//    ): List&lt;LogEntryProto&gt; {&#10;//        val newEntries = parseLogEntries(logElements)&#10;//&#10;//        if (saveToStorage) {&#10;//            // Use StoredAccessLogManager for actual saving&#10;//            newEntries.forEach { entry -&gt;&#10;//                StoredAccessLogManager.addAccessLog(context, entry)&#10;//            }&#10;//        }&#10;//&#10;//        Log.d(TAG, &quot;Processed ${newEntries.size} new log entries&quot;)&#10;//        return newEntries&#10;//    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/arkadst/dataaccessnotifier/LoginStateRepository.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/arkadst/dataaccessnotifier/LoginStateRepository.kt" />
              <option name="originalContent" value="package com.arkadst.dataaccessnotifier&#10;&#10;import android.content.Context&#10;import android.util.Log&#10;import kotlinx.coroutines.CoroutineScope&#10;import kotlinx.coroutines.Dispatchers&#10;import kotlinx.coroutines.flow.MutableStateFlow&#10;import kotlinx.coroutines.flow.StateFlow&#10;import kotlinx.coroutines.flow.map&#10;import kotlinx.coroutines.launch&#10;&#10;private const val TAG = &quot;LoginStateRepository&quot;&#10;object LoginStateRepository {&#10;    private val _isLoggedIn = MutableStateFlow(false)&#10;    val isLoggedIn: StateFlow&lt;Boolean&gt; get() = _isLoggedIn&#10;&#10;//    fun init(context: Context) {&#10;//        CoroutineScope(Dispatchers.IO).launch {&#10;//            context.cookieDataStore.data&#10;//                .map { prefs -&gt;&#10;//                    val isEmpty = prefs.asMap().isEmpty()&#10;//                    Log.d(TAG, &quot;Cookies empty: $isEmpty&quot;)&#10;//                    !isEmpty&#10;//                }.collect { loggedIn -&gt;&#10;//                    Log.d(TAG, &quot;Setting logged in to: $loggedIn&quot;)&#10;//                    _isLoggedIn.value = loggedIn }&#10;//        }&#10;//    }&#10;&#10;    fun init(context: Context) {&#10;        CoroutineScope(Dispatchers.IO).launch {&#10;            context.userInfoDataStore.data&#10;                .map { prefs -&gt;&#10;                    &#10;                    val isEmpty = prefs.asMap().isEmpty()&#10;                    Log.d(TAG, &quot;Cookies empty: $isEmpty&quot;)&#10;                    !isEmpty&#10;                }.collect { loggedIn -&gt;&#10;                    Log.d(TAG, &quot;Setting logged in to: $loggedIn&quot;)&#10;                    _isLoggedIn.value = loggedIn }&#10;        }&#10;    }&#10;&#10;    fun setLoggedIn(isLoggedIn: Boolean) {&#10;        Log.d(TAG, &quot;Manually setting logged in to: $isLoggedIn&quot;)&#10;        _isLoggedIn.value = isLoggedIn&#10;    }&#10;}" />
              <option name="updatedContent" value="package com.arkadst.dataaccessnotifier&#10;&#10;import android.content.Context&#10;import android.util.Log&#10;import kotlinx.coroutines.CoroutineScope&#10;import kotlinx.coroutines.Dispatchers&#10;import kotlinx.coroutines.flow.MutableStateFlow&#10;import kotlinx.coroutines.flow.StateFlow&#10;import kotlinx.coroutines.flow.map&#10;import kotlinx.coroutines.launch&#10;&#10;private const val TAG = &quot;LoginStateRepository&quot;&#10;object LoginStateRepository {&#10;    private val _isLoggedIn = MutableStateFlow(false)&#10;    val isLoggedIn: StateFlow&lt;Boolean&gt; get() = _isLoggedIn&#10;&#10;//    fun init(context: Context) {&#10;//        CoroutineScope(Dispatchers.IO).launch {&#10;//            context.cookieDataStore.data&#10;//                .map { prefs -&gt;&#10;//                    val isEmpty = prefs.asMap().isEmpty()&#10;//                    Log.d(TAG, &quot;Cookies empty: $isEmpty&quot;)&#10;//                    !isEmpty&#10;//                }.collect { loggedIn -&gt;&#10;//                    Log.d(TAG, &quot;Setting logged in to: $loggedIn&quot;)&#10;//                    _isLoggedIn.value = loggedIn }&#10;//        }&#10;//    }&#10;&#10;    fun init(context: Context) {&#10;        CoroutineScope(Dispatchers.IO).launch {&#10;            context.userInfoDataStore.data&#10;                .map { prefs -&gt;&#10;                    val isLoggedIn = prefs[LOGGED_IN_KEY] ?: false&#10;                    Log.d(TAG, &quot;Logged in state: $isLoggedIn&quot;)&#10;                    isLoggedIn&#10;                }.collect { loggedIn -&gt;&#10;                    Log.d(TAG, &quot;Setting logged in to: $loggedIn&quot;)&#10;                    _isLoggedIn.value = loggedIn &#10;                }&#10;        }&#10;    }&#10;&#10;    fun setLoggedIn(isLoggedIn: Boolean) {&#10;        Log.d(TAG, &quot;Manually setting logged in to: $isLoggedIn&quot;)&#10;        _isLoggedIn.value = isLoggedIn&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/arkadst/dataaccessnotifier/MainActivity.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/arkadst/dataaccessnotifier/MainActivity.kt" />
              <option name="originalContent" value="package com.arkadst.dataaccessnotifier&#10;&#10;import android.annotation.SuppressLint&#10;import android.content.Context&#10;import android.os.Bundle&#10;import android.util.Log&#10;import android.webkit.CookieManager&#10;import android.webkit.WebView&#10;import android.widget.Toast&#10;import androidx.activity.ComponentActivity&#10;import androidx.activity.compose.setContent&#10;import androidx.activity.enableEdgeToEdge&#10;import androidx.activity.result.ActivityResultLauncher&#10;import androidx.activity.result.contract.ActivityResultContracts&#10;import androidx.compose.foundation.layout.*&#10;import androidx.compose.foundation.lazy.LazyColumn&#10;import androidx.compose.material3.*&#10;import androidx.compose.runtime.*&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.platform.LocalContext&#10;import androidx.compose.ui.unit.dp&#10;import androidx.compose.ui.viewinterop.AndroidView&#10;import com.arkadst.dataaccessnotifier.ui.theme.DataAccessNotifierTheme&#10;import com.arkadst.dataaccessnotifier.Utils.clearSavedCookies&#10;import com.arkadst.dataaccessnotifier.Utils.fetchUserInfo&#10;import com.arkadst.dataaccessnotifier.Utils.getURL&#10;import kotlinx.coroutines.launch&#10;import androidx.datastore.preferences.core.edit&#10;import androidx.datastore.preferences.core.stringPreferencesKey&#10;import com.arkadst.dataaccessnotifier.NotificationManager.requestNotificationPermission&#10;import com.arkadst.dataaccessnotifier.alarm.AlarmScheduler&#10;&#10;const val LOGIN_URL = &quot;https://www.eesti.ee/timur/oauth2/authorization/govsso?callback_url=https://www.eesti.ee/auth/callback&amp;locale=et&quot;&#10;const val SUCCESS_URL = &quot;https://www.eesti.ee/auth/callback&quot;&#10;private const val TAG = &quot;CookieExtraction&quot;&#10;private const val API_TEST_URL = &quot;https://www.eesti.ee/andmejalgija/api/v1/usages?dataSystemCodes=rahvastikuregister&quot;&#10;&#10;class MainActivity : ComponentActivity() {&#10;&#10;    private lateinit var notificationPermissionLauncher: ActivityResultLauncher&lt;String&gt;&#10;    private suspend fun saveCookies(context: Context, cookies: Map&lt;String, String&gt;) {&#10;        context.cookieDataStore.edit { storedCookies -&gt;&#10;            cookies.forEach { (name, value) -&gt;&#10;                storedCookies[stringPreferencesKey(name)] = value&#10;            }&#10;        }&#10;        Log.d(TAG, &quot;Saved ${cookies.size} cookies&quot;)&#10;    }&#10;&#10;&#10;    private fun cookieStringToMap(cookieString: String): Map&lt;String, String&gt;{&#10;        val cookieMap = mutableMapOf&lt;String, String&gt;()&#10;        cookieString.split(&quot;;&quot;).forEach { cookie -&gt;&#10;            val cookiePair = cookie.trim().split(&quot;=&quot;)&#10;            if (cookiePair.size == 2) {&#10;                val cookieName = cookiePair[0].trim()&#10;                cookieMap[cookieName] = cookie&#10;                Log.d(TAG, &quot;Cookie: $cookieName = $cookie&quot;)&#10;            }&#10;        }&#10;        return cookieMap&#10;    }&#10;&#10;&#10;&#10;    override fun onCreate(savedInstanceState: Bundle?) {&#10;        super.onCreate(savedInstanceState)&#10;&#10;        notificationPermissionLauncher = registerForActivityResult(&#10;            ActivityResultContracts.RequestPermission()&#10;        ) { isGranted -&gt;&#10;            if (isGranted) {&#10;                Log.d(TAG, &quot;Notification permission granted&quot;)&#10;                Toast.makeText(this, &quot;Notification permission granted&quot;, Toast.LENGTH_SHORT).show()&#10;            } else {&#10;                Log.d(TAG, &quot;Notification permission denied&quot;)&#10;                Toast.makeText(this, &quot;Notification permission denied. The app won't work without it.&quot;, Toast.LENGTH_SHORT).show()&#10;                this.finishAffinity()&#10;            }&#10;        }&#10;&#10;        LoginStateRepository.init(this)&#10;        WebView.setWebContentsDebuggingEnabled(true)&#10;        enableEdgeToEdge()&#10;        setContent {&#10;            DataAccessNotifierTheme {&#10;                AuthScreen()&#10;            }&#10;        }&#10;    }&#10;&#10;    override fun onResume() {&#10;        super.onResume()&#10;        if (!AlarmScheduler.requestExactAlarmPermissionIfNeeded(this)){&#10;            requestNotificationPermission(this, notificationPermissionLauncher)&#10;        }&#10;    }&#10;&#10;    @Composable&#10;    fun AuthScreen() {&#10;&#10;        val context = LocalContext.current&#10;        val scope = rememberCoroutineScope()&#10;        val isLoggedIn by LoginStateRepository.isLoggedIn.collectAsState()&#10;        var loggingIn by remember { mutableStateOf(false) }&#10;        val authState = when {&#10;            loggingIn -&gt; AuthState.LoggingIn&#10;            isLoggedIn -&gt; AuthState.LoggedIn&#10;            else -&gt; AuthState.LoggedOut&#10;        }&#10;&#10;        Scaffold(modifier = Modifier.fillMaxSize()) { innerPadding -&gt;&#10;            when (authState) {&#10;                AuthState.LoggedOut -&gt; {&#10;                    LoginButton(&#10;                        modifier = Modifier.padding(innerPadding),&#10;                        onLoginClick = {&#10;                            Toast.makeText(context, &quot;Logging in...&quot;, Toast.LENGTH_SHORT).show()&#10;                            loggingIn = true&#10;                        }&#10;                    )&#10;                }&#10;&#10;                AuthState.LoggingIn -&gt; {&#10;&#10;                    AuthWebView(&#10;                        modifier = Modifier.padding(innerPadding),&#10;                        onAuthComplete = { cookies -&gt;&#10;                            scope.launch {&#10;                                saveCookies(context, cookies)&#10;                                fetchUserInfo(context)&#10;                                loggingIn = false&#10;                                LoginStateRepository.setLoggedIn(true)&#10;                                Toast.makeText(context, &quot;Login successful!&quot;, Toast.LENGTH_SHORT).show()&#10;                            }&#10;                        },&#10;                        onAuthError = {&#10;                            loggingIn = false&#10;                            Toast.makeText(context, &quot;Login failed&quot;, Toast.LENGTH_SHORT).show()&#10;                        }&#10;                    )&#10;                }&#10;&#10;                AuthState.LoggedIn -&gt; {&#10;&#10;                    LaunchedEffect(Unit) {&#10;                        AlarmScheduler.ensureAlarmScheduled(context, 0L)&#10;                    }&#10;&#10;                    LoggedInScreen(&#10;                        modifier = Modifier.padding(innerPadding),&#10;                        onLogout = {&#10;                            scope.launch {&#10;                                clearSavedCookies(context)&#10;                            }&#10;                            stopJwtExtensionService()&#10;                            Toast.makeText(context, &quot;Logged out&quot;, Toast.LENGTH_SHORT).show()&#10;                        }&#10;                    )&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    @Composable&#10;    fun LoginButton(&#10;        modifier: Modifier = Modifier,&#10;        onLoginClick: () -&gt; Unit&#10;    ) {&#10;        Box(&#10;            modifier = modifier.fillMaxSize(),&#10;            contentAlignment = Alignment.Center&#10;        ) {&#10;            Button(onClick = onLoginClick) {&#10;                Text(text = &quot;Log in&quot;)&#10;            }&#10;        }&#10;    }&#10;&#10;    @SuppressLint(&quot;SetJavaScriptEnabled&quot;)&#10;    @Composable&#10;    fun AuthWebView(&#10;        modifier: Modifier = Modifier,&#10;        onAuthComplete: (Map&lt;String, String&gt;) -&gt; Unit,&#10;        onAuthError: () -&gt; Unit&#10;    ) {&#10;        AndroidView(&#10;            modifier = modifier.fillMaxSize(),&#10;            factory = { context -&gt;&#10;                WebView(context).apply {&#10;&#10;&#10;                    val cookieManager = CookieManager.getInstance()&#10;                    cookieManager.setAcceptCookie(true)&#10;                    cookieManager.setAcceptThirdPartyCookies(this, true)&#10;&#10;                    settings.apply {&#10;                        javaScriptEnabled = true&#10;                        domStorageEnabled = true&#10;                    }&#10;&#10;                    webViewClient = MyWebViewClient(&#10;                        { onSuccess, onError -&gt;&#10;                            extractAndReturnCookies( onSuccess, onError)&#10;                        },&#10;                        onAuthComplete,&#10;                        onAuthError&#10;                    )&#10;&#10;                    loadUrl(LOGIN_URL)&#10;                }&#10;            }&#10;        )&#10;    }&#10;&#10;    @Composable&#10;    fun LoggedInScreen(&#10;        modifier: Modifier = Modifier,&#10;        onLogout: () -&gt; Unit&#10;    ) {&#10;        val context = LocalContext.current&#10;        val scope = rememberCoroutineScope()&#10;&#10;        // Use collectAsState to automatically update when new entries are added&#10;        val logEntries by LogEntryManager.loadLogEntriesFlow(context).collectAsState(initial = emptyList())&#10;&#10;        Column(&#10;            modifier = modifier.fillMaxSize().padding(16.dp)&#10;        ) {&#10;            // Logout button at the top&#10;            Row(&#10;                modifier = Modifier.fillMaxWidth(),&#10;                horizontalArrangement = Arrangement.SpaceBetween,&#10;                verticalAlignment = Alignment.CenterVertically&#10;            ) {&#10;                Text(&#10;                    text = &quot;Data Access Monitor&quot;,&#10;                    style = MaterialTheme.typography.headlineSmall&#10;                )&#10;                Button(onClick = onLogout) {&#10;                    Text(text = &quot;Log out&quot;)&#10;                }&#10;            }&#10;&#10;            Spacer(modifier = Modifier.height(16.dp))&#10;&#10;            // Test API button&#10;            Button(&#10;                onClick = {&#10;                    scope.launch {&#10;                        getURL(context, API_TEST_URL)&#10;                    }&#10;                },&#10;                modifier = Modifier.fillMaxWidth()&#10;            ) {&#10;                Text(text = &quot;Test API Request&quot;)&#10;            }&#10;&#10;            Spacer(modifier = Modifier.height(16.dp))&#10;&#10;            // Log entries section&#10;            Text(&#10;                text = &quot;Access Log Entries (${logEntries.size})&quot;,&#10;                style = MaterialTheme.typography.titleMedium&#10;            )&#10;&#10;            Spacer(modifier = Modifier.height(8.dp))&#10;&#10;            // Scrollable list of log entries&#10;            if (logEntries.isEmpty()) {&#10;                Box(&#10;                    modifier = Modifier.fillMaxWidth().padding(32.dp),&#10;                    contentAlignment = Alignment.Center&#10;                ) {&#10;                    Text(&#10;                        text = &quot;No log entries yet&quot;,&#10;                        style = MaterialTheme.typography.bodyMedium,&#10;                        color = MaterialTheme.colorScheme.onSurfaceVariant&#10;                    )&#10;                }&#10;            } else {&#10;                LazyColumn(&#10;                    modifier = Modifier.fillMaxSize(),&#10;                    verticalArrangement = Arrangement.spacedBy(8.dp)&#10;                ) {&#10;                    items(logEntries.size) { index -&gt;&#10;                        LogEntryItem(logEntry = logEntries[index])&#10;                    }&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    @Composable&#10;    fun LogEntryItem(logEntry: LogEntryProto) {&#10;        Card(&#10;            modifier = Modifier.fillMaxWidth(),&#10;            elevation = CardDefaults.cardElevation(defaultElevation = 4.dp)&#10;        ) {&#10;            Column(&#10;                modifier = Modifier.padding(16.dp)&#10;            ) {&#10;                Row(&#10;                    modifier = Modifier.fillMaxWidth(),&#10;                    horizontalArrangement = Arrangement.SpaceBetween&#10;                ) {&#10;                    Text(&#10;                        text = logEntry.infoSystem,&#10;                        style = MaterialTheme.typography.titleSmall,&#10;                        color = MaterialTheme.colorScheme.primary&#10;                    )&#10;                    Text(&#10;                        text = LogEntryManager.formatDisplayTime(logEntry.timestamp),&#10;                        style = MaterialTheme.typography.bodySmall,&#10;                        color = MaterialTheme.colorScheme.onSurfaceVariant&#10;                    )&#10;                }&#10;&#10;                Spacer(modifier = Modifier.height(4.dp))&#10;&#10;                Text(&#10;                    text = logEntry.receiver,&#10;                    style = MaterialTheme.typography.bodyMedium&#10;                )&#10;&#10;                Spacer(modifier = Modifier.height(4.dp))&#10;&#10;                Text(&#10;                    text = logEntry.action,&#10;                    style = MaterialTheme.typography.bodySmall,&#10;                    color = MaterialTheme.colorScheme.onSurfaceVariant&#10;                )&#10;            }&#10;        }&#10;    }&#10;&#10;&#10;    private fun extractAndReturnCookies(&#10;        onSuccess: (Map&lt;String, String&gt;) -&gt; Unit,&#10;        onError: () -&gt; Unit&#10;    ) {&#10;&#10;        val cookieManager = CookieManager.getInstance()&#10;&#10;        val domains = listOf(&#10;            &quot;https://www.eesti.ee&quot;,&#10;        )&#10;&#10;        val allCookies = mutableMapOf&lt;String, String&gt;()&#10;&#10;        domains.forEach { domain -&gt;&#10;            val cookies = cookieManager.getCookie(domain)&#10;            cookies?.let { cookieString -&gt;&#10;                if (cookieString.isNotEmpty()) {&#10;                    Log.d(TAG, &quot;Cookies from $domain: $cookieString&quot;)&#10;                    val cookieMap = cookieStringToMap(cookieString)&#10;                    allCookies.putAll(cookieMap)&#10;                }&#10;            }&#10;        }&#10;&#10;        Log.d(TAG, &quot;Total extracted cookies: ${allCookies.size}&quot;)&#10;        if (allCookies.isNotEmpty()) {&#10;            onSuccess(allCookies)&#10;        } else {&#10;            onError()&#10;        }&#10;    }&#10;&#10;    private fun stopJwtExtensionService() {&#10;        AlarmScheduler.cancelRefresh(this)&#10;        Log.d(TAG, &quot;Alarm cancelled&quot;)&#10;    }&#10;}&#10;&#10;enum class AuthState {&#10;    LoggedOut,&#10;    LoggingIn,&#10;    LoggedIn&#10;}" />
              <option name="updatedContent" value="package com.arkadst.dataaccessnotifier&#10;&#10;import android.annotation.SuppressLint&#10;import android.content.Context&#10;import android.os.Bundle&#10;import android.util.Log&#10;import android.webkit.CookieManager&#10;import android.webkit.WebView&#10;import android.widget.Toast&#10;import androidx.activity.ComponentActivity&#10;import androidx.activity.compose.setContent&#10;import androidx.activity.enableEdgeToEdge&#10;import androidx.activity.result.ActivityResultLauncher&#10;import androidx.activity.result.contract.ActivityResultContracts&#10;import androidx.compose.foundation.layout.*&#10;import androidx.compose.foundation.lazy.LazyColumn&#10;import androidx.compose.material3.*&#10;import androidx.compose.runtime.*&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.platform.LocalContext&#10;import androidx.compose.ui.unit.dp&#10;import androidx.compose.ui.viewinterop.AndroidView&#10;import com.arkadst.dataaccessnotifier.ui.theme.DataAccessNotifierTheme&#10;import com.arkadst.dataaccessnotifier.Utils.clearSavedCookies&#10;import com.arkadst.dataaccessnotifier.Utils.fetchUserInfo&#10;import com.arkadst.dataaccessnotifier.Utils.getURL&#10;import kotlinx.coroutines.launch&#10;import androidx.datastore.preferences.core.edit&#10;import androidx.datastore.preferences.core.stringPreferencesKey&#10;import com.arkadst.dataaccessnotifier.NotificationManager.requestNotificationPermission&#10;import com.arkadst.dataaccessnotifier.alarm.AlarmScheduler&#10;&#10;const val LOGIN_URL = &quot;https://www.eesti.ee/timur/oauth2/authorization/govsso?callback_url=https://www.eesti.ee/auth/callback&amp;locale=et&quot;&#10;const val SUCCESS_URL = &quot;https://www.eesti.ee/auth/callback&quot;&#10;private const val TAG = &quot;CookieExtraction&quot;&#10;private const val API_TEST_URL = &quot;https://www.eesti.ee/andmejalgija/api/v1/usages?dataSystemCodes=rahvastikuregister&quot;&#10;&#10;class MainActivity : ComponentActivity() {&#10;&#10;    private lateinit var notificationPermissionLauncher: ActivityResultLauncher&lt;String&gt;&#10;    private suspend fun saveCookies(context: Context, cookies: Map&lt;String, String&gt;) {&#10;        context.cookieDataStore.edit { storedCookies -&gt;&#10;            cookies.forEach { (name, value) -&gt;&#10;                storedCookies[stringPreferencesKey(name)] = value&#10;            }&#10;        }&#10;        Log.d(TAG, &quot;Saved ${cookies.size} cookies&quot;)&#10;    }&#10;&#10;&#10;    private fun cookieStringToMap(cookieString: String): Map&lt;String, String&gt;{&#10;        val cookieMap = mutableMapOf&lt;String, String&gt;()&#10;        cookieString.split(&quot;;&quot;).forEach { cookie -&gt;&#10;            val cookiePair = cookie.trim().split(&quot;=&quot;)&#10;            if (cookiePair.size == 2) {&#10;                val cookieName = cookiePair[0].trim()&#10;                cookieMap[cookieName] = cookie&#10;                Log.d(TAG, &quot;Cookie: $cookieName = $cookie&quot;)&#10;            }&#10;        }&#10;        return cookieMap&#10;    }&#10;&#10;&#10;&#10;    override fun onCreate(savedInstanceState: Bundle?) {&#10;        super.onCreate(savedInstanceState)&#10;&#10;        notificationPermissionLauncher = registerForActivityResult(&#10;            ActivityResultContracts.RequestPermission()&#10;        ) { isGranted -&gt;&#10;            if (isGranted) {&#10;                Log.d(TAG, &quot;Notification permission granted&quot;)&#10;                Toast.makeText(this, &quot;Notification permission granted&quot;, Toast.LENGTH_SHORT).show()&#10;            } else {&#10;                Log.d(TAG, &quot;Notification permission denied&quot;)&#10;                Toast.makeText(this, &quot;Notification permission denied. The app won't work without it.&quot;, Toast.LENGTH_SHORT).show()&#10;                this.finishAffinity()&#10;            }&#10;        }&#10;&#10;        LoginStateRepository.init(this)&#10;        WebView.setWebContentsDebuggingEnabled(true)&#10;        enableEdgeToEdge()&#10;        setContent {&#10;            DataAccessNotifierTheme {&#10;                AuthScreen()&#10;            }&#10;        }&#10;    }&#10;&#10;    override fun onResume() {&#10;        super.onResume()&#10;        if (!AlarmScheduler.requestExactAlarmPermissionIfNeeded(this)){&#10;            requestNotificationPermission(this, notificationPermissionLauncher)&#10;        }&#10;    }&#10;&#10;    @Composable&#10;    fun AuthScreen() {&#10;&#10;        val context = LocalContext.current&#10;        val scope = rememberCoroutineScope()&#10;        val isLoggedIn by LoginStateRepository.isLoggedIn.collectAsState()&#10;        var loggingIn by remember { mutableStateOf(false) }&#10;        val authState = when {&#10;            loggingIn -&gt; AuthState.LoggingIn&#10;            isLoggedIn -&gt; AuthState.LoggedIn&#10;            else -&gt; AuthState.LoggedOut&#10;        }&#10;&#10;        Scaffold(modifier = Modifier.fillMaxSize()) { innerPadding -&gt;&#10;            when (authState) {&#10;                AuthState.LoggedOut -&gt; {&#10;                    LoginButton(&#10;                        modifier = Modifier.padding(innerPadding),&#10;                        onLoginClick = {&#10;                            Toast.makeText(context, &quot;Logging in...&quot;, Toast.LENGTH_SHORT).show()&#10;                            loggingIn = true&#10;                        }&#10;                    )&#10;                }&#10;&#10;                AuthState.LoggingIn -&gt; {&#10;&#10;                    AuthWebView(&#10;                        modifier = Modifier.padding(innerPadding),&#10;                        onAuthComplete = { cookies -&gt;&#10;                            scope.launch {&#10;                                saveCookies(context, cookies)&#10;                                fetchUserInfo(context)&#10;                                loggingIn = false&#10;                                LoginStateRepository.setLoggedIn(true)&#10;                                Toast.makeText(context, &quot;Login successful!&quot;, Toast.LENGTH_SHORT).show()&#10;                            }&#10;                        },&#10;                        onAuthError = {&#10;                            loggingIn = false&#10;                            Toast.makeText(context, &quot;Login failed&quot;, Toast.LENGTH_SHORT).show()&#10;                        }&#10;                    )&#10;                }&#10;&#10;                AuthState.LoggedIn -&gt; {&#10;&#10;                    LaunchedEffect(Unit) {&#10;                        AlarmScheduler.ensureAlarmScheduled(context, 0L)&#10;                    }&#10;&#10;                    LoggedInScreen(&#10;                        modifier = Modifier.padding(innerPadding),&#10;                        onLogout = {&#10;                            scope.launch {&#10;                                clearSavedCookies(context)&#10;                            }&#10;                            stopJwtExtensionService()&#10;                            Toast.makeText(context, &quot;Logged out&quot;, Toast.LENGTH_SHORT).show()&#10;                        }&#10;                    )&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    @Composable&#10;    fun LoginButton(&#10;        modifier: Modifier = Modifier,&#10;        onLoginClick: () -&gt; Unit&#10;    ) {&#10;        Box(&#10;            modifier = modifier.fillMaxSize(),&#10;            contentAlignment = Alignment.Center&#10;        ) {&#10;            Button(onClick = onLoginClick) {&#10;                Text(text = &quot;Log in&quot;)&#10;            }&#10;        }&#10;    }&#10;&#10;    @SuppressLint(&quot;SetJavaScriptEnabled&quot;)&#10;    @Composable&#10;    fun AuthWebView(&#10;        modifier: Modifier = Modifier,&#10;        onAuthComplete: (Map&lt;String, String&gt;) -&gt; Unit,&#10;        onAuthError: () -&gt; Unit&#10;    ) {&#10;        AndroidView(&#10;            modifier = modifier.fillMaxSize(),&#10;            factory = { context -&gt;&#10;                WebView(context).apply {&#10;&#10;&#10;                    val cookieManager = CookieManager.getInstance()&#10;                    cookieManager.setAcceptCookie(true)&#10;                    cookieManager.setAcceptThirdPartyCookies(this, true)&#10;&#10;                    settings.apply {&#10;                        javaScriptEnabled = true&#10;                        domStorageEnabled = true&#10;                    }&#10;&#10;                    webViewClient = MyWebViewClient(&#10;                        { onSuccess, onError -&gt;&#10;                            extractAndReturnCookies( onSuccess, onError)&#10;                        },&#10;                        onAuthComplete,&#10;                        onAuthError&#10;                    )&#10;&#10;                    loadUrl(LOGIN_URL)&#10;                }&#10;            }&#10;        )&#10;    }&#10;&#10;    @Composable&#10;    fun LoggedInScreen(&#10;        modifier: Modifier = Modifier,&#10;        onLogout: () -&gt; Unit&#10;    ) {&#10;        val context = LocalContext.current&#10;        val scope = rememberCoroutineScope()&#10;&#10;        // Use collectAsState to automatically update when new entries are added&#10;        val logEntries by LogEntryManager.loadLogEntriesFlow(context).collectAsState(initial = emptyList())&#10;&#10;        Column(&#10;            modifier = modifier.fillMaxSize().padding(16.dp)&#10;        ) {&#10;            // Logout button at the top&#10;            Row(&#10;                modifier = Modifier.fillMaxWidth(),&#10;                horizontalArrangement = Arrangement.SpaceBetween,&#10;                verticalAlignment = Alignment.CenterVertically&#10;            ) {&#10;                Text(&#10;                    text = &quot;Data Access Monitor&quot;,&#10;                    style = MaterialTheme.typography.headlineSmall&#10;                )&#10;                Button(onClick = onLogout) {&#10;                    Text(text = &quot;Log out&quot;)&#10;                }&#10;            }&#10;&#10;            Spacer(modifier = Modifier.height(16.dp))&#10;&#10;            // Test API button&#10;            Button(&#10;                onClick = {&#10;                    scope.launch {&#10;                        getURL(context, API_TEST_URL)&#10;                    }&#10;                },&#10;                modifier = Modifier.fillMaxWidth()&#10;            ) {&#10;                Text(text = &quot;Test API Request&quot;)&#10;            }&#10;&#10;            Spacer(modifier = Modifier.height(16.dp))&#10;&#10;            // Log entries section&#10;            Text(&#10;                text = &quot;Access Log Entries (${logEntries.size})&quot;,&#10;                style = MaterialTheme.typography.titleMedium&#10;            )&#10;&#10;            Spacer(modifier = Modifier.height(8.dp))&#10;&#10;            // Scrollable list of log entries&#10;            if (logEntries.isEmpty()) {&#10;                Box(&#10;                    modifier = Modifier.fillMaxWidth().padding(32.dp),&#10;                    contentAlignment = Alignment.Center&#10;                ) {&#10;                    Text(&#10;                        text = &quot;No log entries yet&quot;,&#10;                        style = MaterialTheme.typography.bodyMedium,&#10;                        color = MaterialTheme.colorScheme.onSurfaceVariant&#10;                    )&#10;                }&#10;            } else {&#10;                LazyColumn(&#10;                    modifier = Modifier.fillMaxSize(),&#10;                    verticalArrangement = Arrangement.spacedBy(8.dp)&#10;                ) {&#10;                    items(logEntries.size) { index -&gt;&#10;                        LogEntryItem(logEntry = logEntries[index])&#10;                    }&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    @Composable&#10;    fun LogEntryItem(logEntry: LogEntryProto) {&#10;        Card(&#10;            modifier = Modifier.fillMaxWidth(),&#10;            elevation = CardDefaults.cardElevation(defaultElevation = 4.dp)&#10;        ) {&#10;            Column(&#10;                modifier = Modifier.padding(16.dp)&#10;            ) {&#10;                Row(&#10;                    modifier = Modifier.fillMaxWidth(),&#10;                    horizontalArrangement = Arrangement.SpaceBetween&#10;                ) {&#10;                    Text(&#10;                        text = logEntry.infoSystem,&#10;                        style = MaterialTheme.typography.titleSmall,&#10;                        color = MaterialTheme.colorScheme.primary&#10;                    )&#10;                    Text(&#10;                        text = LogEntryManager.formatDisplayTime(logEntry.timestamp),&#10;                        style = MaterialTheme.typography.bodySmall,&#10;                        color = MaterialTheme.colorScheme.onSurfaceVariant&#10;                    )&#10;                }&#10;&#10;                Spacer(modifier = Modifier.height(4.dp))&#10;&#10;                Text(&#10;                    text = logEntry.receiver,&#10;                    style = MaterialTheme.typography.bodyMedium&#10;                )&#10;&#10;                Spacer(modifier = Modifier.height(4.dp))&#10;&#10;                Text(&#10;                    text = logEntry.action,&#10;                    style = MaterialTheme.typography.bodySmall,&#10;                    color = MaterialTheme.colorScheme.onSurfaceVariant&#10;                )&#10;            }&#10;        }&#10;    }&#10;&#10;&#10;    private fun extractAndReturnCookies(&#10;        onSuccess: (Map&lt;String, String&gt;) -&gt; Unit,&#10;        onError: () -&gt; Unit&#10;    ) {&#10;&#10;        val cookieManager = CookieManager.getInstance()&#10;&#10;        val domains = listOf(&#10;            &quot;https://www.eesti.ee&quot;,&#10;        )&#10;&#10;        val allCookies = mutableMapOf&lt;String, String&gt;()&#10;&#10;        domains.forEach { domain -&gt;&#10;            val cookies = cookieManager.getCookie(domain)&#10;            cookies?.let { cookieString -&gt;&#10;                if (cookieString.isNotEmpty()) {&#10;                    Log.d(TAG, &quot;Cookies from $domain: $cookieString&quot;)&#10;                    val cookieMap = cookieStringToMap(cookieString)&#10;                    allCookies.putAll(cookieMap)&#10;                }&#10;            }&#10;        }&#10;&#10;        Log.d(TAG, &quot;Total extracted cookies: ${allCookies.size}&quot;)&#10;        if (allCookies.isNotEmpty()) {&#10;            onSuccess(allCookies)&#10;        } else {&#10;            onError()&#10;        }&#10;    }&#10;&#10;    private fun stopJwtExtensionService() {&#10;        AlarmScheduler.cancelRefresh(this)&#10;        Log.d(TAG, &quot;Alarm cancelled&quot;)&#10;    }&#10;}&#10;&#10;enum class AuthState {&#10;    LoggedOut,&#10;    LoggingIn,&#10;    LoggedIn&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/arkadst/dataaccessnotifier/NotificationManager.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/arkadst/dataaccessnotifier/NotificationManager.kt" />
              <option name="originalContent" value="package com.arkadst.dataaccessnotifier&#10;&#10;import android.Manifest&#10;import android.app.NotificationChannel&#10;import android.app.NotificationManager&#10;import android.app.PendingIntent&#10;import android.content.Context&#10;import android.content.Intent&#10;import android.content.pm.PackageManager&#10;import android.os.Build&#10;import androidx.activity.result.ActivityResultLauncher&#10;import androidx.core.app.NotificationCompat&#10;import androidx.core.content.ContextCompat&#10;import kotlinx.serialization.json.JsonElement&#10;&#10;object NotificationManager {&#10;&#10;    private const val ACCESS_LOG_NOTIFICATION_ID = 1002&#10;&#10;    fun requestNotificationPermission(&#10;        context: Context,&#10;        permissionLauncher: ActivityResultLauncher&lt;String&gt;&#10;    ): Boolean {&#10;        return if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.TIRAMISU) {&#10;            when (ContextCompat.checkSelfPermission(&#10;                context,&#10;                Manifest.permission.POST_NOTIFICATIONS&#10;            )) {&#10;                PackageManager.PERMISSION_GRANTED -&gt; true&#10;                else -&gt; {&#10;                    permissionLauncher.launch(Manifest.permission.POST_NOTIFICATIONS)&#10;                    false&#10;                }&#10;            }&#10;        } else {&#10;            // Permission not required for Android 12 and below&#10;            true&#10;        }&#10;    }&#10;&#10;    fun showLogoutNotification(context: Context) {&#10;        val notificationManager =&#10;            context.getSystemService(Context.NOTIFICATION_SERVICE) as NotificationManager&#10;&#10;        // Create notification channel for Android 8.0+&#10;        val channel = NotificationChannel(&#10;            &quot;logout_channel&quot;,&#10;            &quot;Logout Notifications&quot;,&#10;            NotificationManager.IMPORTANCE_HIGH&#10;        ).apply {&#10;            description = &quot;Notifications for user logout events&quot;&#10;            setShowBadge(true)&#10;            enableLights(true)&#10;            enableVibration(true)&#10;        }&#10;        notificationManager.createNotificationChannel(channel)&#10;&#10;        // Create intent to open the app&#10;        val intent = context.packageManager.getLaunchIntentForPackage(context.packageName)&#10;        intent?.flags = Intent.FLAG_ACTIVITY_NEW_TASK or Intent.FLAG_ACTIVITY_CLEAR_TASK&#10;&#10;        val pendingIntent = PendingIntent.getActivity(&#10;            context,&#10;            0,&#10;            intent,&#10;            PendingIntent.FLAG_UPDATE_CURRENT or PendingIntent.FLAG_IMMUTABLE&#10;        )&#10;&#10;        // Build notification&#10;        val notification = NotificationCompat.Builder(context, &quot;logout_channel&quot;)&#10;            .setContentTitle(&quot;You have been logged out&quot;)&#10;            .setContentText(&quot;Please log in again to continue using the app.&quot;)&#10;            .setSmallIcon(android.R.drawable.ic_dialog_alert)&#10;            .setContentIntent(pendingIntent)&#10;            .setAutoCancel(true)&#10;            .setPriority(NotificationCompat.PRIORITY_HIGH)&#10;            .setDefaults(NotificationCompat.DEFAULT_ALL)&#10;            .build()&#10;&#10;        notificationManager.notify(1001, notification)&#10;    }&#10;&#10;    fun showAccessLogNotification(context: Context, logEntry: LogEntryProto) {&#10;        val notificationManager =&#10;            context.getSystemService(Context.NOTIFICATION_SERVICE) as NotificationManager&#10;&#10;        // Create notification channel for Android 8.0+&#10;        val channel = NotificationChannel(&#10;            &quot;access_log_channel&quot;,&#10;            &quot;Access Log Notifications&quot;,&#10;            NotificationManager.IMPORTANCE_DEFAULT&#10;        ).apply {&#10;            description = &quot;Notifications for new data access events&quot;&#10;            setShowBadge(true)&#10;            enableLights(true)&#10;            enableVibration(false)&#10;        }&#10;        notificationManager.createNotificationChannel(channel)&#10;&#10;        // Create intent to open the app&#10;        val intent = context.packageManager.getLaunchIntentForPackage(context.packageName)&#10;        intent?.flags = Intent.FLAG_ACTIVITY_NEW_TASK or Intent.FLAG_ACTIVITY_CLEAR_TASK&#10;&#10;        val pendingIntent = PendingIntent.getActivity(&#10;            context,&#10;            0,&#10;            intent,&#10;            PendingIntent.FLAG_UPDATE_CURRENT or PendingIntent.FLAG_IMMUTABLE&#10;        )&#10;&#10;        // Use LogEntryManager for formatting&#10;        val notificationId = logEntry.timestamp.hashCode()&#10;        val shortTime = LogEntryManager.formatShortTime(logEntry.timestamp)&#10;&#10;        // Build individual notification for this entry&#10;        val notification = NotificationCompat.Builder(context, &quot;access_log_channel&quot;)&#10;            .setContentTitle(&quot;Data Access: ${logEntry.infoSystem}&quot;)&#10;            .setContentText(&quot;$shortTime  ${logEntry.receiver}&quot;)&#10;            .setStyle(&#10;                NotificationCompat.BigTextStyle()&#10;                    .bigText(LogEntryManager.formatExpandedNotification(logEntry))&#10;            )&#10;            .setSmallIcon(android.R.drawable.ic_dialog_info)&#10;            .setContentIntent(pendingIntent)&#10;            .setAutoCancel(true)&#10;            .setPriority(NotificationCompat.PRIORITY_DEFAULT)&#10;            .setDefaults(NotificationCompat.DEFAULT_SOUND)&#10;            .setGroup(&quot;access_logs&quot;)&#10;            .build()&#10;&#10;        notificationManager.notify(notificationId, notification)&#10;    }&#10;&#10;    fun showAccessLogNotifications(context: Context, logEntries: List&lt;LogEntryProto&gt;, isFirstTimeLoad: Boolean = false) {&#10;        // Don't show notifications if this is the first time loading data&#10;        if (isFirstTimeLoad) {&#10;            return&#10;        }&#10;&#10;        // Show individual notification for each entry&#10;        logEntries.forEach { logEntry -&gt;&#10;            showAccessLogNotification(context, logEntry)&#10;        }&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.arkadst.dataaccessnotifier&#10;&#10;import android.Manifest&#10;import android.app.NotificationChannel&#10;import android.app.NotificationManager&#10;import android.app.PendingIntent&#10;import android.content.Context&#10;import android.content.Intent&#10;import android.content.pm.PackageManager&#10;import android.os.Build&#10;import androidx.activity.result.ActivityResultLauncher&#10;import androidx.core.app.NotificationCompat&#10;import androidx.core.content.ContextCompat&#10;import kotlinx.serialization.json.JsonElement&#10;&#10;object NotificationManager {&#10;&#10;    private const val ACCESS_LOG_NOTIFICATION_ID = 1002&#10;&#10;    fun requestNotificationPermission(&#10;        context: Context,&#10;        permissionLauncher: ActivityResultLauncher&lt;String&gt;&#10;    ): Boolean {&#10;        return if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.TIRAMISU) {&#10;            when (ContextCompat.checkSelfPermission(&#10;                context,&#10;                Manifest.permission.POST_NOTIFICATIONS&#10;            )) {&#10;                PackageManager.PERMISSION_GRANTED -&gt; true&#10;                else -&gt; {&#10;                    permissionLauncher.launch(Manifest.permission.POST_NOTIFICATIONS)&#10;                    false&#10;                }&#10;            }&#10;        } else {&#10;            // Permission not required for Android 12 and below&#10;            true&#10;        }&#10;    }&#10;&#10;    fun showLogoutNotification(context: Context) {&#10;        val notificationManager =&#10;            context.getSystemService(Context.NOTIFICATION_SERVICE) as NotificationManager&#10;&#10;        // Create notification channel for Android 8.0+&#10;        val channel = NotificationChannel(&#10;            &quot;logout_channel&quot;,&#10;            &quot;Logout Notifications&quot;,&#10;            NotificationManager.IMPORTANCE_HIGH&#10;        ).apply {&#10;            description = &quot;Notifications for user logout events&quot;&#10;            setShowBadge(true)&#10;            enableLights(true)&#10;            enableVibration(true)&#10;        }&#10;        notificationManager.createNotificationChannel(channel)&#10;&#10;        // Create intent to open the app&#10;        val intent = context.packageManager.getLaunchIntentForPackage(context.packageName)&#10;        intent?.flags = Intent.FLAG_ACTIVITY_NEW_TASK or Intent.FLAG_ACTIVITY_CLEAR_TASK&#10;&#10;        val pendingIntent = PendingIntent.getActivity(&#10;            context,&#10;            0,&#10;            intent,&#10;            PendingIntent.FLAG_UPDATE_CURRENT or PendingIntent.FLAG_IMMUTABLE&#10;        )&#10;&#10;        // Build notification&#10;        val notification = NotificationCompat.Builder(context, &quot;logout_channel&quot;)&#10;            .setContentTitle(&quot;You have been logged out&quot;)&#10;            .setContentText(&quot;Please log in again to continue using the app.&quot;)&#10;            .setSmallIcon(android.R.drawable.ic_dialog_alert)&#10;            .setContentIntent(pendingIntent)&#10;            .setAutoCancel(true)&#10;            .setPriority(NotificationCompat.PRIORITY_HIGH)&#10;            .setDefaults(NotificationCompat.DEFAULT_ALL)&#10;            .build()&#10;&#10;        notificationManager.notify(1001, notification)&#10;    }&#10;&#10;    fun showAccessLogNotification(context: Context, logEntry: LogEntryProto) {&#10;        val notificationManager =&#10;            context.getSystemService(Context.NOTIFICATION_SERVICE) as NotificationManager&#10;&#10;        // Create notification channel for Android 8.0+&#10;        val channel = NotificationChannel(&#10;            &quot;access_log_channel&quot;,&#10;            &quot;Access Log Notifications&quot;,&#10;            NotificationManager.IMPORTANCE_DEFAULT&#10;        ).apply {&#10;            description = &quot;Notifications for new data access events&quot;&#10;            setShowBadge(true)&#10;            enableLights(true)&#10;            enableVibration(false)&#10;        }&#10;        notificationManager.createNotificationChannel(channel)&#10;&#10;        // Create intent to open the app&#10;        val intent = context.packageManager.getLaunchIntentForPackage(context.packageName)&#10;        intent?.flags = Intent.FLAG_ACTIVITY_NEW_TASK or Intent.FLAG_ACTIVITY_CLEAR_TASK&#10;&#10;        val pendingIntent = PendingIntent.getActivity(&#10;            context,&#10;            0,&#10;            intent,&#10;            PendingIntent.FLAG_UPDATE_CURRENT or PendingIntent.FLAG_IMMUTABLE&#10;        )&#10;&#10;        // Use LogEntryManager for formatting&#10;        val notificationId = logEntry.timestamp.hashCode()&#10;        val displayTime = LogEntryManager.formatDisplayTime(logEntry.timestamp)&#10;&#10;        // Build individual notification for this entry&#10;        val notification = NotificationCompat.Builder(context, &quot;access_log_channel&quot;)&#10;            .setContentTitle(&quot;Data Access: ${logEntry.infoSystem}&quot;)&#10;            .setContentText(&quot;$displayTime  ${logEntry.receiver}&quot;)&#10;            .setStyle(&#10;                NotificationCompat.BigTextStyle()&#10;                    .bigText(LogEntryManager.formatExpandedNotification(logEntry))&#10;            )&#10;            .setSmallIcon(android.R.drawable.ic_dialog_info)&#10;            .setContentIntent(pendingIntent)&#10;            .setAutoCancel(true)&#10;            .setPriority(NotificationCompat.PRIORITY_DEFAULT)&#10;            .setDefaults(NotificationCompat.DEFAULT_SOUND)&#10;            .setGroup(&quot;access_logs&quot;)&#10;            .build()&#10;&#10;        notificationManager.notify(notificationId, notification)&#10;    }&#10;&#10;    fun showAccessLogNotifications(context: Context, logEntries: List&lt;LogEntryProto&gt;, isFirstTimeLoad: Boolean = false) {&#10;        // Don't show notifications if this is the first time loading data&#10;        if (isFirstTimeLoad) {&#10;            return&#10;        }&#10;&#10;        // Show individual notification for each entry&#10;        logEntries.forEach { logEntry -&gt;&#10;            showAccessLogNotification(context, logEntry)&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/arkadst/dataaccessnotifier/StoredAccessLogManager.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/arkadst/dataaccessnotifier/StoredAccessLogManager.kt" />
              <option name="originalContent" value="package com.arkadst.dataaccessnotifier&#10;&#10;import android.content.Context&#10;import kotlinx.coroutines.flow.first&#10;&#10;object StoredAccessLogManager {&#10;    &#10;    suspend fun addAccessLog(context: Context, logEntry: LogEntry) {&#10;        context.accessLogsDataStore.updateData { currentLogs -&gt;&#10;            val existingHashes = currentLogs.entriesList.map { it.contentHash }.toSet()&#10;            val hash = LogEntryManager.generateContentHash(logEntry)&#10;            &#10;            val builder = currentLogs.toBuilder()&#10;            if (!existingHashes.contains(hash)) {&#10;                val protoEntry = LogEntryProto.newBuilder()&#10;                    .setTimestamp(logEntry.timestamp)&#10;                    .setReceiver(logEntry.receiver)&#10;                    .setInfoSystem(logEntry.infoSystem)&#10;                    .setAction(logEntry.action)&#10;                    .setContentHash(hash)&#10;                    .build()&#10;                    &#10;                builder.addEntries(protoEntry)&#10;            }&#10;            &#10;            builder.build()&#10;        }&#10;    }&#10;&#10;    suspend fun hasAccessLog(context: Context, logEntry: LogEntry): Boolean {&#10;        val logs = context.accessLogsDataStore.data.first()&#10;        val hash = LogEntryManager.generateContentHash(logEntry)&#10;        return logs.entriesList.any { it.contentHash == hash }&#10;    }&#10;&#10;    suspend fun getAllAccessLogs(context: Context): List&lt;LogEntry&gt; {&#10;        val logs = context.accessLogsDataStore.data.first()&#10;        return logs.entriesList.map { proto -&gt;&#10;            LogEntry(&#10;                timestamp = proto.timestamp,&#10;                receiver = proto.receiver,&#10;                infoSystem = proto.infoSystem,&#10;                action = proto.action&#10;            )&#10;        }.sortedByDescending { it.timestamp }&#10;    }&#10;&#10;    suspend fun clearAccessLogs(context: Context) {&#10;        context.accessLogsDataStore.updateData {&#10;            AccessLogsProto.getDefaultInstance()&#10;        }&#10;    }&#10;    &#10;    suspend fun getAccessLogCount(context: Context): Int {&#10;        val logs = context.accessLogsDataStore.data.first()&#10;        return logs.entriesCount&#10;    }&#10;}" />
              <option name="updatedContent" value="package com.arkadst.dataaccessnotifier&#10;&#10;import android.content.Context&#10;import kotlinx.coroutines.flow.first&#10;&#10;object StoredAccessLogManager {&#10;    &#10;    suspend fun addAccessLog(context: Context, logEntry: LogEntryProto) {&#10;        context.accessLogsDataStore.updateData { currentLogs -&gt;&#10;            val existingHashes = currentLogs.entriesList.map { it.contentHash }.toSet()&#10;            &#10;            val builder = currentLogs.toBuilder()&#10;            if (!existingHashes.contains(logEntry.contentHash)) {&#10;                builder.addEntries(logEntry)&#10;            }&#10;            &#10;            builder.build()&#10;        }&#10;    }&#10;&#10;    suspend fun hasAccessLog(context: Context, logEntry: LogEntryProto): Boolean {&#10;        val logs = context.accessLogsDataStore.data.first()&#10;        return logs.entriesList.any { it.contentHash == logEntry.contentHash }&#10;    }&#10;&#10;    suspend fun getAllAccessLogs(context: Context): List&lt;LogEntryProto&gt; {&#10;        val logs = context.accessLogsDataStore.data.first()&#10;        return logs.entriesList.sortedByDescending { it.timestamp }&#10;    }&#10;&#10;    suspend fun clearAccessLogs(context: Context) {&#10;        context.accessLogsDataStore.updateData {&#10;            AccessLogsProto.getDefaultInstance()&#10;        }&#10;    }&#10;    &#10;    suspend fun getAccessLogCount(context: Context): Int {&#10;        val logs = context.accessLogsDataStore.data.first()&#10;        return logs.entriesCount&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/arkadst/dataaccessnotifier/Utils.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/arkadst/dataaccessnotifier/Utils.kt" />
              <option name="originalContent" value="package com.arkadst.dataaccessnotifier&#10;&#10;import android.content.Context&#10;import android.util.Log&#10;import android.webkit.CookieManager&#10;import androidx.compose.ui.platform.LocalContext&#10;import androidx.datastore.core.CorruptionException&#10;import androidx.datastore.core.DataStore&#10;import androidx.datastore.core.IOException&#10;import androidx.datastore.core.handlers.ReplaceFileCorruptionHandler&#10;import androidx.datastore.dataStore&#10;import androidx.datastore.preferences.core.Preferences&#10;import androidx.datastore.preferences.core.booleanPreferencesKey&#10;import androidx.datastore.preferences.core.edit&#10;import androidx.datastore.preferences.preferencesDataStore&#10;import androidx.datastore.preferences.core.stringPreferencesKey&#10;import kotlinx.coroutines.Dispatchers&#10;import kotlinx.coroutines.delay&#10;import kotlinx.coroutines.withContext&#10;import kotlinx.serialization.json.Json.Default.parseToJsonElement&#10;import kotlinx.serialization.json.JsonElement&#10;import kotlinx.serialization.json.jsonObject&#10;import kotlinx.serialization.json.jsonPrimitive&#10;import okhttp3.Response&#10;import com.arkadst.dataaccessnotifier.NotificationManager.showLogoutNotification&#10;import com.arkadst.dataaccessnotifier.Utils.setFirstUse&#10;import com.arkadst.dataaccessnotifier.alarm.AlarmScheduler&#10;import kotlinx.coroutines.flow.first&#10;&#10;const val RETRIES_KEY = &quot;retries&quot;&#10;private const val COOKIE_PREFS = &quot;auth_cookies&quot;&#10;private const val USER_INFO_PREFS = &quot;user_info&quot;&#10;const val JWT_EXTEND_URL = &quot;https://www.eesti.ee/timur/jwt/extend-jwt-session&quot;&#10;const val DATA_TRACKER_API_URL =&#10;    &quot;https://www.eesti.ee/andmejalgija/api/v1/usages?dataSystemCodes=digiregistratuur&amp;dataSystemCodes=elamislubade_ja_toolubade_register&amp;dataSystemCodes=kinnistusraamat&amp;dataSystemCodes=kutseregister&amp;dataSystemCodes=maksukohustuslaste_register&amp;dataSystemCodes=infosusteem_polis&amp;dataSystemCodes=politsei_taktikalise_juhtimise_andmekogu&amp;dataSystemCodes=pollumajandusloomade_register&amp;dataSystemCodes=pollumajandustoetuste_ja_pollumassiivide_register&amp;dataSystemCodes=rahvastikuregister&amp;dataSystemCodes=retseptikeskus&amp;dataSystemCodes=sotsiaalkaitse_infosusteem&amp;dataSystemCodes=sotsiaalteenuste_ja_toetuste_register&amp;dataSystemCodes=tooinspektsiooni_tooelu_infosusteem&amp;dataSystemCodes=tootuskindlustuse_andmekogu&quot;&#10;&#10;val PERSONAL_CODE_KEY = stringPreferencesKey(&quot;personalCode&quot;)&#10;val FIRST_NAME_KEY = stringPreferencesKey(&quot;firstName&quot;)&#10;val FIRST_USE_KEY = booleanPreferencesKey(&quot;firstUse&quot;)&#10;val Context.cookieDataStore: DataStore&lt;Preferences&gt; by preferencesDataStore(name = COOKIE_PREFS)&#10;val Context.userInfoDataStore: DataStore&lt;Preferences&gt; by preferencesDataStore(name = USER_INFO_PREFS)&#10;val Context.accessLogsDataStore: DataStore&lt;AccessLogsProto&gt; by dataStore(&#10;    fileName = &quot;access_logs.pb&quot;,&#10;    serializer = AccessLogsSerializer,&#10;    corruptionHandler = ReplaceFileCorruptionHandler {&#10;        Log.w(&quot;DataStore&quot;, &quot;AccessLogs proto corruption detected, resetting to default&quot;)&#10;        setFirstUse(, true)&#10;        AccessLogsProto.getDefaultInstance()&#10;    }&#10;)&#10;&#10;&#10;private const val TAG = &quot;getURL&quot;&#10;&#10;object Utils {&#10;&#10;    suspend fun getURL(context: Context, url: String): Pair&lt;Int, String&gt; {&#10;        return withContext(Dispatchers.IO) {&#10;            try {&#10;                Log.d(TAG, &quot;Starting API test request to: $url&quot;)&#10;&#10;                val cookieJar = SessionManagementCookieJar(context)&#10;                val client = okhttp3.OkHttpClient.Builder()&#10;                    .cookieJar(cookieJar)&#10;                    .build()&#10;&#10;                val request = okhttp3.Request.Builder()&#10;                    .url(url)&#10;                    .addHeader(&#10;                        &quot;User-Agent&quot;,&#10;                        &quot;Mozilla/5.0 (X11; Linux x86_64; rv:140.0) Gecko/20100101 Firefox/140.0&quot;&#10;                    )&#10;                    .build()&#10;&#10;                val response: Response = client.newCall(request).execute()&#10;&#10;                if (response.code !in 500..599) {&#10;                    Log.d(TAG, &quot;Saving ${cookieJar.cookieBuffer.size} cookies&quot;)&#10;                    context.cookieDataStore.edit { prefs -&gt;&#10;                        cookieJar.cookieBuffer.forEach { (key, value) -&gt;&#10;                            prefs[key] = value&#10;                        }&#10;                    }&#10;                }&#10;&#10;                val returnValue = Pair(response.code, response.body.string())&#10;                Log.d(TAG, &quot;API Response Code: ${returnValue.first}&quot;)&#10;                Log.d(TAG, &quot;API Response: ${returnValue.second}&quot;)&#10;                response.close()&#10;&#10;                return@withContext returnValue&#10;            } catch (ex: IOException) {&#10;                Log.e(TAG, &quot;Error during API request: ${ex.message}&quot;)&#10;                delay(10 * 1000)&#10;                return@withContext getURL(context, url)&#10;            }&#10;&#10;        }&#10;    }&#10;&#10;     fun clearSavedCookies(context: Context) {&#10;        Log.d(&quot;ClearCookies&quot;, &quot;Clearing saved cookies&quot;)&#10;//        context.cookieDataStore.edit { prefs -&gt;&#10;//            prefs.clear()&#10;//        }&#10;&#10;        CookieManager.getInstance().removeAllCookies(null)&#10;        LoginStateRepository.setLoggedIn(false)&#10;        Log.d(&quot;ClearCookies&quot;, &quot;Cleared all cookies&quot;)&#10;    }&#10;&#10;    suspend fun fetchUserInfo(context: Context) {&#10;        try {&#10;            val response = getURL(context, &quot;https://www.eesti.ee/api/xroad/v2/rr/kodanik/info&quot;)&#10;            val body: String = response.second&#10;            Log.d(&quot;UserInfo&quot;, &quot;Response Body: $body&quot;)&#10;&#10;            val jsonElement = parseToJsonElement(body)&#10;&#10;            parseAndSaveUserInfo(context, jsonElement)&#10;        } catch (e: Exception) {&#10;            Log.e(&quot;UserInfo&quot;, &quot;Failed to fetch user info: ${e.message}&quot;, e)&#10;        }&#10;    }&#10;&#10;    private suspend fun parseAndSaveUserInfo(context: Context, jsonElement: JsonElement) {&#10;        val jsonObject = jsonElement.jsonObject&#10;&#10;        // Extract and clean data&#10;        val personalCode = jsonObject[&quot;personalCode&quot;]?.jsonPrimitive?.content?.cleanJsonString()?.removePrefix(&quot;EE&quot;)&#10;        val firstName = jsonObject[&quot;firstName&quot;]?.jsonPrimitive?.content?.cleanJsonString()&#10;&#10;        // Save all user info in a single DataStore edit operation&#10;        context.userInfoDataStore.edit { prefs -&gt;&#10;            personalCode?.let {&#10;                prefs[PERSONAL_CODE_KEY] = it&#10;                Log.d(&quot;UserInfo&quot;, &quot;Saved personal code: $it&quot;)&#10;            } ?: Log.w(&quot;UserInfo&quot;, &quot;Personal code not found in response&quot;)&#10;&#10;            firstName?.let {&#10;                prefs[FIRST_NAME_KEY] = it&#10;                Log.d(&quot;UserInfo&quot;, &quot;Saved first name: $it&quot;)&#10;            } ?: Log.w(&quot;UserInfo&quot;, &quot;First name not found in response&quot;)&#10;        }&#10;    }&#10;&#10;    private fun String.cleanJsonString(): String {&#10;        return this.replace(&quot;\&quot;&quot;, &quot;&quot;).trim()&#10;    }&#10;&#10;    suspend fun logOut(context: Context) {&#10;        AlarmScheduler.cancelRefresh(context)&#10;        clearSavedCookies(context)&#10;        showLogoutNotification(context)&#10;    }&#10;&#10;    suspend fun isFirstUse(context: Context): Boolean {&#10;        return context.userInfoDataStore.data.first()[FIRST_USE_KEY] ?: true&#10;    }&#10;    suspend fun setFirstUse(context: Context, isFirstUse: Boolean) {&#10;        context.userInfoDataStore.edit { prefs -&gt;&#10;            prefs[FIRST_USE_KEY] = isFirstUse&#10;        }&#10;    }&#10;&#10;&#10;}" />
              <option name="updatedContent" value="package com.arkadst.dataaccessnotifier&#10;&#10;import android.content.Context&#10;import android.util.Log&#10;import android.webkit.CookieManager&#10;import androidx.compose.ui.platform.LocalContext&#10;import androidx.datastore.core.CorruptionException&#10;import androidx.datastore.core.DataStore&#10;import androidx.datastore.core.IOException&#10;import androidx.datastore.core.handlers.ReplaceFileCorruptionHandler&#10;import androidx.datastore.dataStore&#10;import androidx.datastore.preferences.core.Preferences&#10;import androidx.datastore.preferences.core.booleanPreferencesKey&#10;import androidx.datastore.preferences.core.edit&#10;import androidx.datastore.preferences.preferencesDataStore&#10;import androidx.datastore.preferences.core.stringPreferencesKey&#10;import kotlinx.coroutines.Dispatchers&#10;import kotlinx.coroutines.delay&#10;import kotlinx.coroutines.withContext&#10;import kotlinx.serialization.json.Json.Default.parseToJsonElement&#10;import kotlinx.serialization.json.JsonElement&#10;import kotlinx.serialization.json.jsonObject&#10;import kotlinx.serialization.json.jsonPrimitive&#10;import okhttp3.Response&#10;import com.arkadst.dataaccessnotifier.NotificationManager.showLogoutNotification&#10;import com.arkadst.dataaccessnotifier.Utils.setFirstUse&#10;import com.arkadst.dataaccessnotifier.alarm.AlarmScheduler&#10;import kotlinx.coroutines.flow.first&#10;&#10;const val RETRIES_KEY = &quot;retries&quot;&#10;private const val COOKIE_PREFS = &quot;auth_cookies&quot;&#10;private const val USER_INFO_PREFS = &quot;user_info&quot;&#10;const val JWT_EXTEND_URL = &quot;https://www.eesti.ee/timur/jwt/extend-jwt-session&quot;&#10;const val DATA_TRACKER_API_URL =&#10;    &quot;https://www.eesti.ee/andmejalgija/api/v1/usages?dataSystemCodes=digiregistratuur&amp;dataSystemCodes=elamislubade_ja_toolubade_register&amp;dataSystemCodes=kinnistusraamat&amp;dataSystemCodes=kutseregister&amp;dataSystemCodes=maksukohustuslaste_register&amp;dataSystemCodes=infosusteem_polis&amp;dataSystemCodes=politsei_taktikalise_juhtimise_andmekogu&amp;dataSystemCodes=pollumajandusloomade_register&amp;dataSystemCodes=pollumajandustoetuste_ja_pollumassiivide_register&amp;dataSystemCodes=rahvastikuregister&amp;dataSystemCodes=retseptikeskus&amp;dataSystemCodes=sotsiaalkaitse_infosusteem&amp;dataSystemCodes=sotsiaalteenuste_ja_toetuste_register&amp;dataSystemCodes=tooinspektsiooni_tooelu_infosusteem&amp;dataSystemCodes=tootuskindlustuse_andmekogu&quot;&#10;&#10;val PERSONAL_CODE_KEY = stringPreferencesKey(&quot;personalCode&quot;)&#10;val FIRST_NAME_KEY = stringPreferencesKey(&quot;firstName&quot;)&#10;val FIRST_USE_KEY = booleanPreferencesKey(&quot;firstUse&quot;)&#10;val Context.cookieDataStore: DataStore&lt;Preferences&gt; by preferencesDataStore(name = COOKIE_PREFS)&#10;val Context.userInfoDataStore: DataStore&lt;Preferences&gt; by preferencesDataStore(name = USER_INFO_PREFS)&#10;val Context.accessLogsDataStore: DataStore&lt;AccessLogsProto&gt; by dataStore(&#10;    fileName = &quot;access_logs.pb&quot;,&#10;    serializer = AccessLogsSerializer,&#10;    corruptionHandler = ReplaceFileCorruptionHandler {&#10;        Log.w(&quot;DataStore&quot;, &quot;AccessLogs proto corruption detected, resetting to default&quot;)&#10;        AccessLogsProto.getDefaultInstance()&#10;    }&#10;)&#10;&#10;&#10;private const val TAG = &quot;getURL&quot;&#10;&#10;object Utils {&#10;&#10;    suspend fun getURL(context: Context, url: String): Pair&lt;Int, String&gt; {&#10;        return withContext(Dispatchers.IO) {&#10;            try {&#10;                Log.d(TAG, &quot;Starting API test request to: $url&quot;)&#10;&#10;                val cookieJar = SessionManagementCookieJar(context)&#10;                val client = okhttp3.OkHttpClient.Builder()&#10;                    .cookieJar(cookieJar)&#10;                    .build()&#10;&#10;                val request = okhttp3.Request.Builder()&#10;                    .url(url)&#10;                    .addHeader(&#10;                        &quot;User-Agent&quot;,&#10;                        &quot;Mozilla/5.0 (X11; Linux x86_64; rv:140.0) Gecko/20100101 Firefox/140.0&quot;&#10;                    )&#10;                    .build()&#10;&#10;                val response: Response = client.newCall(request).execute()&#10;&#10;                if (response.code !in 500..599) {&#10;                    Log.d(TAG, &quot;Saving ${cookieJar.cookieBuffer.size} cookies&quot;)&#10;                    context.cookieDataStore.edit { prefs -&gt;&#10;                        cookieJar.cookieBuffer.forEach { (key, value) -&gt;&#10;                            prefs[key] = value&#10;                        }&#10;                    }&#10;                }&#10;&#10;                val returnValue = Pair(response.code, response.body.string())&#10;                Log.d(TAG, &quot;API Response Code: ${returnValue.first}&quot;)&#10;                Log.d(TAG, &quot;API Response: ${returnValue.second}&quot;)&#10;                response.close()&#10;&#10;                return@withContext returnValue&#10;            } catch (ex: IOException) {&#10;                Log.e(TAG, &quot;Error during API request: ${ex.message}&quot;)&#10;                delay(10 * 1000)&#10;                return@withContext getURL(context, url)&#10;            }&#10;&#10;        }&#10;    }&#10;&#10;     fun clearSavedCookies(context: Context) {&#10;        Log.d(&quot;ClearCookies&quot;, &quot;Clearing saved cookies&quot;)&#10;//        context.cookieDataStore.edit { prefs -&gt;&#10;//            prefs.clear()&#10;//        }&#10;&#10;        CookieManager.getInstance().removeAllCookies(null)&#10;        LoginStateRepository.setLoggedIn(false)&#10;        Log.d(&quot;ClearCookies&quot;, &quot;Cleared all cookies&quot;)&#10;    }&#10;&#10;    suspend fun fetchUserInfo(context: Context) {&#10;        try {&#10;            val response = getURL(context, &quot;https://www.eesti.ee/api/xroad/v2/rr/kodanik/info&quot;)&#10;            val body: String = response.second&#10;            Log.d(&quot;UserInfo&quot;, &quot;Response Body: $body&quot;)&#10;&#10;            val jsonElement = parseToJsonElement(body)&#10;&#10;            parseAndSaveUserInfo(context, jsonElement)&#10;        } catch (e: Exception) {&#10;            Log.e(&quot;UserInfo&quot;, &quot;Failed to fetch user info: ${e.message}&quot;, e)&#10;        }&#10;    }&#10;&#10;    private suspend fun parseAndSaveUserInfo(context: Context, jsonElement: JsonElement) {&#10;        val jsonObject = jsonElement.jsonObject&#10;&#10;        // Extract and clean data&#10;        val personalCode = jsonObject[&quot;personalCode&quot;]?.jsonPrimitive?.content?.cleanJsonString()?.removePrefix(&quot;EE&quot;)&#10;        val firstName = jsonObject[&quot;firstName&quot;]?.jsonPrimitive?.content?.cleanJsonString()&#10;&#10;        // Save all user info in a single DataStore edit operation&#10;        context.userInfoDataStore.edit { prefs -&gt;&#10;            personalCode?.let {&#10;                prefs[PERSONAL_CODE_KEY] = it&#10;                Log.d(&quot;UserInfo&quot;, &quot;Saved personal code: $it&quot;)&#10;            } ?: Log.w(&quot;UserInfo&quot;, &quot;Personal code not found in response&quot;)&#10;&#10;            firstName?.let {&#10;                prefs[FIRST_NAME_KEY] = it&#10;                Log.d(&quot;UserInfo&quot;, &quot;Saved first name: $it&quot;)&#10;            } ?: Log.w(&quot;UserInfo&quot;, &quot;First name not found in response&quot;)&#10;        }&#10;    }&#10;&#10;    private fun String.cleanJsonString(): String {&#10;        return this.replace(&quot;\&quot;&quot;, &quot;&quot;).trim()&#10;    }&#10;&#10;    suspend fun logOut(context: Context) {&#10;        AlarmScheduler.cancelRefresh(context)&#10;        clearSavedCookies(context)&#10;        showLogoutNotification(context)&#10;    }&#10;&#10;    suspend fun isFirstUse(context: Context): Boolean {&#10;        return context.userInfoDataStore.data.first()[FIRST_USE_KEY] ?: true&#10;    }&#10;    suspend fun setFirstUse(context: Context, isFirstUse: Boolean) {&#10;        context.userInfoDataStore.edit { prefs -&gt;&#10;            prefs[FIRST_USE_KEY] = isFirstUse&#10;        }&#10;    }&#10;&#10;&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/proto/access_logs.proto">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/proto/access_logs.proto" />
              <option name="originalContent" value="syntax = &quot;proto3&quot;;&#10;&#10;option java_package = &quot;com.arkadst.dataaccessnotifier&quot;;&#10;option java_multiple_files = true;&#10;&#10;message LogEntryProto {&#10;  string timestamp = 1;&#10;  string receiver = 2;&#10;  string info_system = 3;&#10;  string action = 4;&#10;  string content_hash = 5; // Hash of all fields for deduplication&#10;}&#10;&#10;message AccessLogsProto {&#10;  repeated LogEntryProto entries = 1; // Simple repeated field, deduplication handled by hash checking&#10;}&#10;" />
              <option name="updatedContent" value="syntax = &quot;proto3&quot;;&#10;&#10;option java_package = &quot;com.arkadst.dataaccessnotifier&quot;;&#10;option java_multiple_files = true;&#10;&#10;message LogEntryProto {&#10;  string timestamp = 1;&#10;  string receiver = 2;&#10;  string info_system = 3;&#10;  string action = 4;&#10;  string content_hash = 5; // Hash of all fields for deduplication&#10;}&#10;&#10;message AccessLogsProto {&#10;  repeated LogEntryProto entries = 1; // Simple repeated field, deduplication handled by hash checking&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>